{"meta":{"title":"Ino's Blog - 筱冉的温馨小窝","subtitle":"","description":"Ino - 博客网是一个专注于学习分享与教程的一个网站!","author":"Ino","url":"https://aqu.iyunmc.cn","root":"/"},"pages":[{"title":"","date":"2023-05-30T06:15:56.462Z","updated":"2023-05-30T06:15:56.462Z","comments":true,"path":"404.html","permalink":"https://aqu.iyunmc.cn/404","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"文章分类","date":"2023-05-30T06:35:53.694Z","updated":"2023-05-30T06:35:53.694Z","comments":true,"path":"categories/index.html","permalink":"https://aqu.iyunmc.cn/categories/","excerpt":"","text":""},{"title":"","date":"2023-06-05T03:18:48.233Z","updated":"2023-06-05T03:18:48.233Z","comments":true,"path":"friends/index.html","permalink":"https://aqu.iyunmc.cn/friends/","excerpt":"","text":"我 的 朋 友 们"},{"title":"","date":"2023-06-05T07:00:53.562Z","updated":"2023-06-05T07:00:53.562Z","comments":true,"path":"about/index.html","permalink":"https://aqu.iyunmc.cn/about/","excerpt":"","text":"关 于 我 关于我 首先欢迎您的到来！ 欢迎来到我的博客！我是一个热爱编程和技术的人，喜欢分享自己的知识和经验。在这个博客上，我会分享一些有趣的程序、干货、技巧、开发教程、心情和学习记录等等！在我从一开始学习编程到现在，在不断的查资料中，我发现很多人都会把一些重要的东西记录下来，方便以后查看。在现在这个互联网时代，快速的学习过程，甚至没有时间打开笔墨，博客确实是个不错的选择。既能写一年后还能看得懂博客，又能把经验变成不可替代性可见的东西。在提高自己总结性能力的同时，也让博客成为了自己一份独特的名片。 最后引用互联网上看到的一句话：“屌丝程序员的逆袭一般分两步：让自己变得牛逼，让别人知道你牛逼。”如果您对我的博客有任何建议或者想法，欢迎在评论区留言，我会尽快回复！我的能力我是一名拥有多年编程经验的开发者，熟练掌握以下技能： 编程语言： Java、 Python、 JavaScript、 C++等； 开发框架： Spring、 Flask、 React、 Vue等； 数据库： MySQL、 Oracle、 Redis等; 工具： Git、 Docker等。 版权声明博客内的所有原创内容（包括但不限于文章、图像等）除特别声明外均采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议，任何人都可以自由传播，但不得用于商用且必须署名并以相同方式分享。 隐私原则本站内目前涉及到浏览者隐私的只有一个地方，就是留言区（文章评论）。当你留言时，你的电子邮箱、Cookies信息和IPv4/IPv6地址都会被记录。这些信息仅为了改进我们的网站质量和可能的交流沟通。我们不会将这些信息进行展示、出租或出售给任何人。但以下情况除外： 只有透露您的个人资料，才能提供您所要求的产品和服务； 我们需要听从法庭传票、法律命令或遵循法律程序； 我们发现您违反了本站已发布的条款或声明。"},{"title":"鸣谢项目和社区贡献者","date":"2023-05-30T06:35:51.728Z","updated":"2023-05-30T06:35:51.728Z","comments":true,"path":"contributors/index.html","permalink":"https://aqu.iyunmc.cn/contributors/","excerpt":"Volantis 社区的发展离不开团队大佬们的无私奉献和社区小伙伴们的热情互助。每一个心怀梦想、有着独特见解的朋友都可以成为团队的一员。目前 Volantis 社区正处于建设初期，我们缺少各方面的人才，如果您使用主题至少一个月且长期活跃于社区，例如： 解答 issues &#x2F; discussions 提交有效的建议 官网文档补全&#x2F;纠错 发现并收录有意思的文章（搭建博客方面）到官网 我们非常欢迎您的加入，请在论坛发帖告诉我们。","text":"Volantis 社区的发展离不开团队大佬们的无私奉献和社区小伙伴们的热情互助。每一个心怀梦想、有着独特见解的朋友都可以成为团队的一员。目前 Volantis 社区正处于建设初期，我们缺少各方面的人才，如果您使用主题至少一个月且长期活跃于社区，例如： 解答 issues &#x2F; discussions 提交有效的建议 官网文档补全&#x2F;纠错 发现并收录有意思的文章（搭建博客方面）到官网 我们非常欢迎您的加入，请在论坛发帖告诉我们。 感谢开发者 感谢社区建设者 如何参与社区建设社区建设主要包括 Issues Discussions(论坛) 官网博客收录 官网文档维护 几个方面。 如何维护文档目前 Volantis 已是已知的 Hexo 主题中文档最全面的，但仍有部分功能缺少明确的文档、部分文档已经过时，如果您发现了遗漏或者错误之处，我们非常希望您能够帮忙完善一下。 Volantis 官网支持 CI ，您可以直接在线编辑源码： 在线编辑文档https://github.com/volantis-x/community/tree/main/source 发布与分享文章每位用户在使用或更新主题的时候都需要阅读官网的文档，收录的相关内容能帮助用户更高效地上手，同时也能够提高被收录的文章的曝光率。如果在官网能看到更多的有价值的文章，就会有更多 Volantis 用户或者非 Volantis 用户来访问。 如果您有或者发现了与 Hexo 博客搭建相关的文章，可以转载外链到 Volantis 官网，示例如下： _posts/blogs/2020-05-17-pjax.md---title: Volantis 主题部署 Pjaxdate: 2020-05-17updated: 2020-08-07categories: [开发心得]author: inksslink: https://inkss.cn/blog/76993423/description: 本篇文章记录了我对 Volantis 主题做 Pjax 兼容的种种，大抵算是种记录吧~headimg: # 可以设置文章头图backup: https://web.archive.org/web/xxxxxxxxxx # 将页面存档到互联网档案馆 archive.org 的存档链接 https://web.archive.org/save--- 如果这篇文章的作者是第一次出现在官网，还需要在 _data/author.yml 文件中添加作者信息，例如： _data/author.yml...inkss: name: 枋柚梓 avatar: https://cdn.jsdelivr.net/gh/inkss/common@1.4.2/hexo/img/static/avatar.jpg url: https://inkss.cn 注意事项文章存放在 _posts/blogs/ 目录中，且文件名格式为「年-月-日-文章话题」。鼓励原创文章，摘要部分300字符以内。如果想不出摘要可以不写，不要在摘要里重复一遍文章标题。最好选择一个文章分类，如果现有的分类中没有合适的，可以自己新增。如果有文章头图，请确保图片内最多只有一个单词或短语，图片不清晰或者与文章无关的话不建议使用。不仅限于自己的文章，可以在征得文章作者同意的情况下将其链接收录到官网。 在线编辑文档https://github.com/volantis-x/community/tree/main/source/_posts/blogs"},{"title":"所有标签","date":"2023-05-30T06:35:33.205Z","updated":"2023-05-30T06:35:33.205Z","comments":true,"path":"tags/index.html","permalink":"https://aqu.iyunmc.cn/tags/","excerpt":"","text":""},{"title":"","date":"2023-05-30T06:16:09.584Z","updated":"2023-05-30T06:16:09.584Z","comments":true,"path":"examples/index.html","permalink":"https://aqu.iyunmc.cn/examples/","excerpt":"示 例 博 客 社区维护团队的博客xaoxuu开发者MHuiG划水Colsrch开发者inkss摸鱼volantis-x.js.orgTest Site For Development 使用 Volantis 的博客示例","text":"示 例 博 客 社区维护团队的博客xaoxuu开发者MHuiG划水Colsrch开发者inkss摸鱼volantis-x.js.orgTest Site For Development 使用 Volantis 的博客示例 如何添加自己的博客链接 第一步：新建 Issue 按照格式填写并提交 &#123; &quot;title&quot;: &quot;&quot;, &quot;description&quot;: &quot;&quot;, &quot;screenshot&quot;: &quot;&quot;, &quot;url&quot;: &quot;&quot;, &quot;avatar&quot;: &quot;&quot;, &quot;version&quot;: &quot;版本：^4.0&quot;&#125;为了提高图片加载速度，建议优化图片尺寸：打开 压缩图 上传自己的截图，将图片的高度调整到 360px 后下载。将压缩后的图片上传到 ImgURL免费图床 或 去不图床 并使用此图片链接作为截图链接。 第二步：刷新 回来刷新即可生效。 如何更新自己的博客链接 如果是自己创建的 issue ，可以自己修改。 如果是管理员创建的，请自己重新创建一份，然后让管理员删掉旧的。"},{"title":"","date":"2023-06-05T07:16:52.715Z","updated":"2023-06-05T07:16:52.715Z","comments":false,"path":"history/index.html","permalink":"https://aqu.iyunmc.cn/history/","excerpt":"","text":"时 间 轴 2021-2-3 添加自动夜间模式的功能 2021-1-23 博客小成 基于Hexo下的Volantis主题建设 2020-12-27 全站完全自写html 使用Valine评论系统"},{"title":"","date":"2023-06-05T07:22:08.334Z","updated":"2023-06-05T07:22:08.334Z","comments":true,"path":"messages/index.html","permalink":"https://aqu.iyunmc.cn/messages/","excerpt":"","text":"🍭欢迎你的来访，请遵守相关法律法规，文明灌水，谢谢合作~"},{"title":"","date":"2023-06-04T12:03:48.385Z","updated":"2023-06-04T12:03:48.385Z","comments":true,"path":"notes/Docker.html","permalink":"https://aqu.iyunmc.cn/notes/Docker","excerpt":"","text":"DockerDocker是一个快速交付应用、运行应用的技术 可以将程序机器依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统 运行时利用沙箱机制形成隔离容器，各个应用互不干扰 启动、移除都可以通过一行命令完成，方便快捷 镜像：将应用及其依赖、环境、配置打包在一起 容器：镜像运行起来就是容器，一个镜像可以运行多个容器 Docker结构：服务端：接受命令或远程请求，操作镜像或容器 客户端：发送命令或者请求到Docker服务端 Docker基本操作-镜像1.基本操作docker images 查看镜像 docker rmi 删除指定镜像 docker pull 拉取镜像 docker push 推送镜像 docker save 保存镜像tar docker load 加载tar镜像 docker ps 查看所有运行的容器及状态 docker rm 删除容器（不能删除运行中的容器，除非添加 -f 参数） docker logs 查看容器运行日志 docker exec -it [容器名] [要执行的命令] 进入容器执行命令 2.容器命令①.创建运行一个Nginx容器步骤一：去docker hub查看Nginx的容器运行命令 docker run --name containerName -p 80:80 -d nginx 命令解读： docker run：创建并运行一个容器 --name：给容器起一个名字，比如叫做ng -p：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口 -d：后台运行容器 nginx：镜像名称，例如nginx docker run命令的常见参数 --name：指定容器名称 -p：指定端口映射 -d：让容器后台运行 查看容器日志的命令docker logs 添加 -f 参数可以持续查看日志 查看容器状态docker ps 2.1 进入Nginx容器，修改HTML文件内容，添加“Ino欢迎你”步骤一：进入容器docker exec -it mn bash 命令解读： docker exec：进入容器内部，执行一个命令 -it：给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 mn：要进入的容器的名称 bash：进入容器后执行的命令，bash是一个linux终端交互命令 ②.操作数据卷数据卷的作用： 将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全 docker volume [COMMAND] docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作： create 创建一个volume inspect 显示一个或多个volume的信息 ls 列出所有的volume prune 删除未使用的volume rm 删除一个或多个指定的volume 创建数据卷 docker volume craete html 2.查看所有数据 docker volume ls 3.查看数据卷详细信息卷 docker volume inspect html 2.2 利用数据卷操作nginx容器① 创建容器并挂载数据卷到容器内的HTML目录 docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx ② 进入html数据卷所在位置，并修改HTML内容 # 查看html数据卷的位置docker volume inspect html# 进入该目录cd /var/lib/docker/volumes/html/_data# 修改文件vi index.html 2.3 创建并运行一个MySQL容器，将宿主机目录直接挂载到容器提示:目录挂载与数据卷挂载的语法是类似的: -v[宿主机目录]:[容器内目录] -v[宿主机文件]:[容器内文件] 实现思路如下: 1．在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像 2．创建目录&#x2F;tmp&#x2F;myql&#x2F;data 3．创建目录&#x2F;tmp&#x2F;myql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tmp&#x2F;myql&#x2F;conf 4．去DockerHub查阅资料，创建并运行MySQL容器，要求: 挂载&#x2F;tmp&#x2F;myql&#x2F;data到mysql容器内数据存储目录 挂载&#x2F;tmp&#x2F;myql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件 设置MySQL密码 docker run --name mysql -e MYSQL_ROOT_PASSWORD=adg153 -p 3307:3306 -v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf -v /tmp/mysql/data:/var/lib/mysql -d mysql:5.7.25 自定义镜像 - 镜像结构竟像是分层结构，每一层成为一个Layer（层） BaseImage层：包含基本的系统函数库、环境变量、文件系统 Entrypoint：入口，是镜像中应用启动的命令（systemctl start mysql.service） 其他：在BaseImage基础上添加依赖、安装程序、完成整个应用的安装和配置 2.CentOS7安装DockerCompose2.1.下载Linux下需要通过命令下载： # 安装curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件： 上传到/usr/local/bin/目录也可以。 2.2.修改文件权限修改文件权限： # 修改权限chmod +x /usr/local/bin/docker-compose 2.3.Base自动补全命令：# 补全命令curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 如果这里出现错误，需要修改自己的hosts文件： echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts 3.Docker镜像仓库搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。 官网地址：https://hub.docker.com/_/registry 3.1.简化版镜像仓库Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。 搭建方式比较简单，命令如下： docker run -d \\ --restart=always \\ --name registry \\ -p 5000:5000 \\ -v registry-data:/var/lib/registry \\ registry 命令中挂载了一个数据卷registry-data到容器内的&#x2F;var&#x2F;lib&#x2F;registry 目录，这是私有镜像库存放数据的目录。 访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像 3.2.带有图形化界面版本使用DockerCompose部署带有图象界面的DockerRegistry，命令如下： version: &#x27;3.0&#x27;services: registry: image: registry volumes: - ./registry-data:/var/lib/registry ui: image: joxit/docker-registry-ui:static ports: - 8080:80 environment: - REGISTRY_TITLE=传智教育私有仓库 - REGISTRY_URL=http://registry:5000 depends_on: - registry 3.3.配置Docker信任地址我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置： # 打开要修改的文件vi /etc/docker/daemon.json# 添加内容：&quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;]# 重加载systemctl daemon-reload# 重启dockersystemctl restart docker"},{"title":"","date":"2023-05-31T08:53:39.376Z","updated":"2023-05-31T08:53:39.376Z","comments":true,"path":"notes/Redis.html","permalink":"https://aqu.iyunmc.cn/notes/Redis","excerpt":"","text":"Redis认识NoSQLSQL： 结构化（Structured） 关联的（Relational） SQL查询 ACID A（Atomicity）：原子性 C（Consistency）：一致性 I（Isolation）：隔离性 D（Durability）：持久性 Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 [1] NoSQL： 非结构化 无关联的 非SQL BASE 缓存穿透：缓存穿透是指查询一条数据库和缓存都没有的一条数据，就会 一直查询数据库，对数据库的访问压力就会增大。 常见的2种解决方案： 缓存空对象 优点：简单实现，维护方便 缺点： 额外的内存消耗 可能造成短期的不一致 布隆过滤 优点：内存占用较少，没有多余的key 缺点： 实现复杂 存在误判可能 增强id的复杂度，避免被猜测id规律 做好数据的基础格式校验 加强用户权限校验 做好热点参数的限流 缓存穿透：缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力 解决方案： 给不同的Key的TTL添加随机值 利用Redis集群提高服务的可用性 给缓存业务添加降级限流策略 给业务添加多级缓存 缓存击穿：缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击 解决方案： 互斥锁 逻辑过期 解决方案 优点 缺点 互斥锁 没有额外的内存消耗保证一致性实现简单 县城需要等待，性能受影响可能有死锁风险 逻辑过期 线程无需等待，性能较好 不保证一致性有额外内存消耗实现复杂 全局唯一ID生成策略： UUIDUUID是指在一台机器在同一时间中生成的数字在所有机器中都是唯一的。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12) 优点： 简单，代码方便 生成ID性能非常好，基本不会有性能问题，本地生成，没有网络消耗 全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对 缺点： 没有排序，无法保证趋势递增 UUID往往是使用字符串存储，查询的效率比较低 存储空间比较大，UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用，如果是海量数据库，就需要考虑存储量的问题 信息不安全，基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置 传输数据量大，并且不可读 Redis自增 优点： 不依赖于数据库，灵活方便，且性能优于数据库 数字ID天然排序，对分页或者需要排序的结果很有帮助 缺点： 如果系统中没有Redis，还需要引入新的组件，增加系统复杂度 需要编码和配置的工作量比较大 Redis是单线程的，若造成阻塞，则会引发高并发问题，需要处理好集群与主从关系 snowflake算法snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。生成的是一个64位的二进制正整数，然后转换成10进制的数。64位二进制数由如下部分组成： * SnowFlake的结构如下(每部分用-分开):* 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000* (1-10-10-10-10-10-1-5-5-12) (1-41-10-12) 优点 简单高效，生成速度快 时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增 灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求 缺点 依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成 在分布式环境上，每个服务器的时钟不可能完全同步，有时会出现不是全局递增的情况 数据库自增 优点： 简单，代码方便，性能可以接受 数字ID天然排序，对分页或者需要排序的结果很有帮助 缺点： 不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理 在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险 在性能达不到要求的情况下，比较难于扩展 如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦 分表分库的时候会有麻烦"},{"title":"","date":"2023-05-31T08:59:09.159Z","updated":"2023-05-31T08:59:09.159Z","comments":true,"path":"notes/SpringAMQP.html","permalink":"https://aqu.iyunmc.cn/notes/SpringAMQP","excerpt":"","text":"MQ1.同步调用的优点 时效性较强，可以立即得到结果 2.同步调用的问题 耦合度高 性能和吞吐能力下降 有额外的资源消耗 有级联失败问题 3.异步通信的优点 耦合度低 吞吐量提升 故障隔离 流量削峰 4.异步通信的缺点 依赖于Broker的可靠性、安全性、吞吐能力 架构复杂了，业务没有明显的流程线，不好追踪管理 什么是MQMQ（MessageQueue），中文是消息队列，字面来看就是存放消息的队列，也就是事件驱动架构中的Broker RabbitMQ入门RabbitMQ中的几个概念 channel：操作MQ的工具 exchange：路由消息到队列中 queue：缓存消息 virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组 HelloWorld案例官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色： publisher：消息发布这，将消息发送到队列queue queue：消息队列，负责接收并缓存消息 consumer：订阅队列，处理队列中的消息 基本消息队列的消息发送流程 建立connection 创建channel 利用channel声明队列 利用channel向队列发送消息 基本消息队列的消息接收流程 建立connection 创建channel 利用channel声明队列 定义consumer的消费行为handleDelivery() 利用channel将消费者与队列绑定 SpringAMQP什么是SpringAMQPAMQP（Advanced Message Queuing Protocol） 是用于在应用程序或之间传递业务消息的开放标准 该协议与语言和平台无关，更符合微服务中独立性的要求。 SpringAMQP是基于AMQP协议定义的一套API规范，提供了模板来发送和接受消息。包含两部分，其中spring-amqp是基础抽象，spring-rabbit是底层的默认实现。 SpringAMQP如何接收消息？ 引入amqp的starter依赖 配置RabbitMQ地址 定义类，添加@Component注解 类中声明方法，添加@RabbitListener注解，方法参数就是消息 注意：消息一旦消费就会从队列中删除，RabbitMQ没有消息回溯功能 发布（Publish）、订阅（Subscribe）发布订阅模式与之前案例的区别就是允许将同意消息发送给多个消费者。实现方式是加入了exchange（交换机） 常见的exchange类型包括： Fanout：广播 Direct：路由 Topic：话题 注意：exchange负责消息路由，而不是存储，路由失败则消息丢失 SpringAMQP - FanoutExchangeFanoutExchange交换机的作用 接受publisher发送的消息 将消息按照规则路由到绑定的队列 不能缓存消息，路由失败，消息会丢失 FanoutExchange的会将消息路由到每个绑定的队列 DirectExchangeDirect交换机与Fanout交换机的差异 Fanout交换机将消息路由给每一个与之绑定的队列 Direct交换机根据RoutingKey判断路由给哪个队列 如果多个队列具有相同的RoutingKey，则与Fanout功能类似 基于@RabbitListener注解声明队列和交换机有哪些常见注解 @Queue @Exchange SpringAMQP - 消息转换器Spring的对消息对象的处理时由org.springframework.amqp.support.converter.MessageConverter来处理的。而默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化。 如果要修改只需要定义一个MessageConverter类型的Bean即可。推荐用JSON方式序列化，步骤如下： 在publisher服务引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.9.10&gt; &lt;/dependency&gt; - 在publisher服务声明MessageConverter：- ``` @Bean public MessageConverter jsonMessageConverter()&#123; return new Jackson2JsonMessageConverter(); &#125; SpringAMQP中消息的序列化和反序列化如何实现 利用MessageConverter实现的，默认是JDK的序列化 注意发送方和接收方必须使用相同的MessageConverter"},{"title":"","date":"2023-05-31T08:58:46.347Z","updated":"2023-05-31T08:58:46.347Z","comments":true,"path":"notes/Ribbon负载均衡.html","permalink":"https://aqu.iyunmc.cn/notes/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1","excerpt":"","text":"Ribbon负载均衡1. Ribbon负载均衡规则 规则接口是IRule 默认实现是ZoneAvoidanceRule，根据zone选择服务列表，然后轮询 2. 负载均衡自定义方式 代码方式：配置灵活，但修改时需要重新打包发布 配置方式：直观，方便，无需重新打包发布，但是无法做全局配置 3. 饥饿加载 开启饥饿加载 指定饥饿加载的微服务名称 spring: cloud: nacos: server-addr: localhost:8848 # nacos 服务地址 discovery: cluster-name: SH # 集群名称 Nacos服务分级模型1. Nacos服务分级存储模型 一级是服务，例如userservice 二级是集群，例如杭州或上海 三级是实例，例如杭州机房的某台部署了userservice的服务器 2. 如何设置实例的集群属性修改application.yml文件，添加spring.cloud.nacos.discovery.cluster-name属性即可 Nacos负载均衡策略1. NacosRule负载均衡策略 优先选择同集群服务实例列表 本地集群找不到提供者，才去找其他集群寻找，并且会报警告 确定了可用实例列表后，再采用随机负载均衡挑选实例 Nacos注册中心 - 加权负载均衡1. 实例的权重控制 Nacos控制台可以设置势实例的权重值，0~1 同集群内的多个实例，权重越高被访问的频率越高 权重设置为0则完全不会被访问"},{"title":"","date":"2023-05-31T08:59:28.003Z","updated":"2023-05-31T08:59:28.003Z","comments":true,"path":"notes/SpringSecurity从入门到精通.html","permalink":"https://aqu.iyunmc.cn/notes/SpringSecurity%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A","excerpt":"","text":"SpringSecurity从入门到精通课程介绍 0. 简介​ Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。 ​ 一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。 ​ 一般Web应用的需要进行认证和授权。 ​ 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户 ​ 授权：经过认证后判断当前用户是否有权限进行某个操作 ​ 而认证和授权也是SpringSecurity作为安全框架的核心功能。 1. 快速入门1.1 准备工作​ 我们先要搭建一个简单的SpringBoot工程 ① 设置父工程 添加依赖 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ② 创建启动类 @SpringBootApplicationpublic class SecurityApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SecurityApplication.class,args); &#125;&#125; ③ 创建Controller import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 1.2 引入SpringSecurity​ 在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; ​ 引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。 ​ 必须登陆之后才能对接口进行访问。 2. 认证2.1 登陆校验流程 2.2 原理初探​ 想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。 2.2.1 SpringSecurity完整流程​ SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。 ​ 图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。 UsernamePasswordAuthenticationFilter:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。 ExceptionTranslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。 FilterSecurityInterceptor：负责权限校验的过滤器。 ​ ​ 我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。 2.2.2 认证流程详解 概念速查: Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。 AuthenticationManager接口：定义了认证Authentication的方法 UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。 UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。 2.3 解决问题2.3.1 思路分析登录 ​ ①自定义登录接口 ​ 调用ProviderManager的方法进行认证 如果认证通过生成jwt ​ 把用户信息存入redis中 ​ ②自定义UserDetailsService ​ 在这个实现类中去查询数据库 校验： ​ ①定义Jwt认证过滤器 ​ 获取token ​ 解析token获取其中的userid ​ 从redis中获取用户信息 ​ 存入SecurityContextHolder 2.3.2 准备工作①添加依赖 &lt;!--redis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--fastjson依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.33&lt;/version&gt;&lt;/dependency&gt;&lt;!--jwt依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; ② 添加Redis相关配置 import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.type.TypeFactory;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;import com.alibaba.fastjson.parser.ParserConfig;import org.springframework.util.Assert;import java.nio.charset.Charset;/** * Redis使用FastJson序列化 * * @author sg */public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt;&#123; public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); private Class&lt;T&gt; clazz; static &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); &#125; public FastJsonRedisSerializer(Class&lt;T&gt; clazz) &#123; super(); this.clazz = clazz; &#125; @Override public byte[] serialize(T t) throws SerializationException &#123; if (t == null) &#123; return new byte[0]; &#125; return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET); &#125; @Override public T deserialize(byte[] bytes) throws SerializationException &#123; if (bytes == null || bytes.length &lt;= 0) &#123; return null; &#125; String str = new String(bytes, DEFAULT_CHARSET); return JSON.parseObject(str, clazz); &#125; protected JavaType getJavaType(Class&lt;?&gt; clazz) &#123; return TypeFactory.defaultInstance().constructType(clazz); &#125;&#125; import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean @SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class); // 使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(serializer); // Hash的key也采用StringRedisSerializer的序列化方式 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(serializer); template.afterPropertiesSet(); return template; &#125;&#125; ③ 响应类 import com.fasterxml.jackson.annotation.JsonInclude;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@JsonInclude(JsonInclude.Include.NON_NULL)public class ResponseResult&lt;T&gt; &#123; /** * 状态码 */ private Integer code; /** * 提示信息，如果有错误时，前端可以获取该字段进行提示 */ private String msg; /** * 查询到的结果数据， */ private T data; public ResponseResult(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; public ResponseResult(Integer code, T data) &#123; this.code = code; this.data = data; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public ResponseResult(Integer code, String msg, T data) &#123; this.code = code; this.msg = msg; this.data = data; &#125;&#125; ④工具类 import io.jsonwebtoken.Claims;import io.jsonwebtoken.JwtBuilder;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;import java.util.Date;import java.util.UUID;/** * JWT工具类 */public class JwtUtil &#123; //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = &quot;sangeng&quot;; public static String getUUID()&#123; String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); return token; &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @return */ public static String createJWT(String subject) &#123; JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间 return builder.compact(); &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @param ttlMillis token超时时间 * @return */ public static String createJWT(String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间 return builder.compact(); &#125; private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123; SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; SecretKey secretKey = generalKey(); long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if(ttlMillis==null)&#123; ttlMillis=JwtUtil.JWT_TTL; &#125; long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); return Jwts.builder() .setId(uuid) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(&quot;sg&quot;) // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate); &#125; /** * 创建token * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间 return builder.compact(); &#125; public static void main(String[] args) throws Exception &#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;; Claims claims = parseJWT(token); System.out.println(claims); &#125; /** * 生成加密后的秘钥 secretKey * @return */ public static SecretKey generalKey() &#123; byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;); return key; &#125; /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception &#123; SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); &#125;&#125; import java.util.*;import java.util.concurrent.TimeUnit;@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)@Componentpublic class RedisCache&#123; @Autowired public RedisTemplate redisTemplate; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 */ public &lt;T&gt; void setCacheObject(final String key, final T value) &#123; redisTemplate.opsForValue().set(key, value); &#125; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 * @param timeout 时间 * @param timeUnit 时间颗粒度 */ public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit) &#123; redisTemplate.opsForValue().set(key, value, timeout, timeUnit); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout) &#123; return expire(key, timeout, TimeUnit.SECONDS); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @param unit 时间单位 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout, final TimeUnit unit) &#123; return redisTemplate.expire(key, timeout, unit); &#125; /** * 获得缓存的基本对象。 * * @param key 缓存键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; T getCacheObject(final String key) &#123; ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue(); return operation.get(key); &#125; /** * 删除单个对象 * * @param key */ public boolean deleteObject(final String key) &#123; return redisTemplate.delete(key); &#125; /** * 删除集合对象 * * @param collection 多个对象 * @return */ public long deleteObject(final Collection collection) &#123; return redisTemplate.delete(collection); &#125; /** * 缓存List数据 * * @param key 缓存的键值 * @param dataList 待缓存的List数据 * @return 缓存的对象 */ public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList) &#123; Long count = redisTemplate.opsForList().rightPushAll(key, dataList); return count == null ? 0 : count; &#125; /** * 获得缓存的list对象 * * @param key 缓存的键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; List&lt;T&gt; getCacheList(final String key) &#123; return redisTemplate.opsForList().range(key, 0, -1); &#125; /** * 缓存Set * * @param key 缓存键值 * @param dataSet 缓存的数据 * @return 缓存数据的对象 */ public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet) &#123; BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key); Iterator&lt;T&gt; it = dataSet.iterator(); while (it.hasNext()) &#123; setOperation.add(it.next()); &#125; return setOperation; &#125; /** * 获得缓存的set * * @param key * @return */ public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key) &#123; return redisTemplate.opsForSet().members(key); &#125; /** * 缓存Map * * @param key * @param dataMap */ public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap) &#123; if (dataMap != null) &#123; redisTemplate.opsForHash().putAll(key, dataMap); &#125; &#125; /** * 获得缓存的Map * * @param key * @return */ public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * 往Hash中存入数据 * * @param key Redis键 * @param hKey Hash键 * @param value 值 */ public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value) &#123; redisTemplate.opsForHash().put(key, hKey, value); &#125; /** * 获取Hash中的数据 * * @param key Redis键 * @param hKey Hash键 * @return Hash中的对象 */ public &lt;T&gt; T getCacheMapValue(final String key, final String hKey) &#123; HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash(); return opsForHash.get(key, hKey); &#125; /** * 删除Hash中的数据 * * @param key * @param hkey */ public void delCacheMapValue(final String key, final String hkey) &#123; HashOperations hashOperations = redisTemplate.opsForHash(); hashOperations.delete(key, hkey); &#125; /** * 获取多个Hash中的数据 * * @param key Redis键 * @param hKeys Hash键集合 * @return Hash对象集合 */ public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys) &#123; return redisTemplate.opsForHash().multiGet(key, hKeys); &#125; /** * 获得缓存的基本对象列表 * * @param pattern 字符串前缀 * @return 对象列表 */ public Collection&lt;String&gt; keys(final String pattern) &#123; return redisTemplate.keys(pattern); &#125;&#125; import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class WebUtils&#123; /** * 将字符串渲染到客户端 * * @param response 渲染对象 * @param string 待渲染的字符串 * @return null */ public static String renderString(HttpServletResponse response, String string) &#123; try &#123; response.setStatus(200); response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.getWriter().print(string); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; ⑤实体类 import java.io.Serializable;import java.util.Date;/** * 用户表(User)实体类 * * @author 三更 */@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Serializable &#123; private static final long serialVersionUID = -40356785423868312L; /** * 主键 */ private Long id; /** * 用户名 */ private String userName; /** * 昵称 */ private String nickName; /** * 密码 */ private String password; /** * 账号状态（0正常 1停用） */ private String status; /** * 邮箱 */ private String email; /** * 手机号 */ private String phonenumber; /** * 用户性别（0男，1女，2未知） */ private String sex; /** * 头像 */ private String avatar; /** * 用户类型（0管理员，1普通用户） */ private String userType; /** * 创建人的用户id */ private Long createBy; /** * 创建时间 */ private Date createTime; /** * 更新人 */ private Long updateBy; /** * 更新时间 */ private Date updateTime; /** * 删除标志（0代表未删除，1代表已删除） */ private Integer delFlag;&#125; 2.3.3 实现2.3.3.1 数据库校验用户​ 从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。 准备工作​ 我们先创建一个用户表， 建表语句如下： CREATE TABLE `sys_user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;, `nick_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;, `password` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;, `status` CHAR(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;, `email` VARCHAR(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `sex` CHAR(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;, `avatar` VARCHAR(128) DEFAULT NULL COMMENT &#x27;头像&#x27;, `user_type` CHAR(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;, `create_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;, `create_time` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `update_time` DATETIME DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` INT(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27; ​ 引入MybatisPuls和mysql驱动的依赖 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; ​ 配置数据库信息 spring: datasource: url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver ​ 定义Mapper接口 public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; ​ 修改User实体类 类名上加@TableName(value = &quot;sys_user&quot;) ,id字段上加 @TableId ​ 配置Mapper扫描 @SpringBootApplication@MapperScan(&quot;com.sangeng.mapper&quot;)public class SimpleSecurityApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class); System.out.println(run); &#125;&#125; ​ 添加junit依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; ​ 测试MP是否能正常使用 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@SpringBootTestpublic class MapperTest &#123; @Autowired private UserMapper userMapper; @Test public void testUserMapper()&#123; List&lt;User&gt; users = userMapper.selectList(null); System.out.println(users); &#125;&#125; 核心代码实现创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //根据用户名查询用户信息 LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); //如果查询不到数据就通过抛出异常来给出提示 if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //TODO 根据用户查询权限信息 添加到LoginUser中 //封装成UserDetails对象返回 return new LoginUser(user); &#125;&#125; 因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Data@NoArgsConstructor@AllArgsConstructorpublic class LoginUser implements UserDetails &#123; private User user; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return null; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; 注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如 这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。 2.3.3.2 密码加密存储​ 实际项目中我们不会把密码明文存储在数据库中。 ​ 默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。 ​ 我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。 ​ 我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。 ​ 我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 2.3.3.3 登陆接口​ 接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。 ​ 在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。 ​ 认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。 @RestControllerpublic class LoginController &#123; @Autowired private LoginServcie loginServcie; @PostMapping(&quot;/user/login&quot;) public ResponseResult login(@RequestBody User user)&#123; return loginServcie.login(user); &#125;&#125; /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; ​ @Servicepublic class LoginServiceImpl implements LoginServcie &#123; @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisCache redisCache; @Override public ResponseResult login(User user) &#123; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if(Objects.isNull(authenticate))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //使用userid生成token LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); //authenticate存入redis redisCache.setCacheObject(&quot;login:&quot;+userId,loginUser); //把token响应给前端 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;,jwt); return new ResponseResult(200,&quot;登陆成功&quot;,map); &#125;&#125; 2.3.3.4 认证过滤器​ 我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。 ​ 使用userid去redis中获取对应的LoginUser对象。 ​ 然后封装Authentication对象存入SecurityContextHolder @Componentpublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123; @Autowired private RedisCache redisCache; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; //获取token String token = request.getHeader(&quot;token&quot;); if (!StringUtils.hasText(token)) &#123; //放行 filterChain.doFilter(request, response); return; &#125; //解析token String userid; try &#123; Claims claims = JwtUtil.parseJWT(token); userid = claims.getSubject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;token非法&quot;); &#125; //从redis中获取用户信息 String redisKey = &quot;login:&quot; + userid; LoginUser loginUser = redisCache.getCacheObject(redisKey); if(Objects.isNull(loginUser))&#123; throw new RuntimeException(&quot;用户未登录&quot;); &#125; //存入SecurityContextHolder //TODO 获取权限信息封装到Authentication中 UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser,null,null); SecurityContextHolder.getContext().setAuthentication(authenticationToken); //放行 filterChain.doFilter(request, response); &#125;&#125; /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Autowired JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter; @Override protected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //把token校验过滤器添加到过滤器链中 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; 2.3.3.5 退出登陆​ 我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class LoginServiceImpl implements LoginServcie &#123; @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisCache redisCache; @Override public ResponseResult login(User user) &#123; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if(Objects.isNull(authenticate))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //使用userid生成token LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); //authenticate存入redis redisCache.setCacheObject(&quot;login:&quot;+userId,loginUser); //把token响应给前端 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;,jwt); return new ResponseResult(200,&quot;登陆成功&quot;,map); &#125; @Override public ResponseResult logout() &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Long userid = loginUser.getUser().getId(); redisCache.deleteObject(&quot;login:&quot;+userid); return new ResponseResult(200,&quot;退出成功&quot;); &#125;&#125; 3. 授权3.0 权限系统的作用​ 例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。 ​ 总结起来就是不同的用户可以使用不同的功能。这就是权限系统要去实现的效果。 ​ 我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。 ​ 所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。 ​ 3.1 授权基本流程​ 在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。 ​ 所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。 ​ 然后设置我们的资源所需要的权限即可。 3.2 授权实现3.2.1 限制访问资源所需权限​ SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。 ​ 但是要使用它我们需要先开启相关配置。 @EnableGlobalMethodSecurity(prePostEnabled = true) ​ 然后就可以使用对应的注解。@PreAuthorize @RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;test&#x27;)&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 3.2.2 封装权限信息​ 我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。 ​ 我们先直接把权限信息写死封装到UserDetails中进行测试。 ​ 我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。 package com.sangeng.domain;import com.alibaba.fastjson.annotation.JSONField;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.Collection;import java.util.List;import java.util.stream.Collectors;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Data@NoArgsConstructorpublic class LoginUser implements UserDetails &#123; private User user; //存储权限信息 private List&lt;String&gt; permissions; public LoginUser(User user,List&lt;String&gt; permissions) &#123; this.user = user; this.permissions = permissions; &#125; //存储SpringSecurity所需要的权限信息的集合 @JSONField(serialize = false) private List&lt;GrantedAuthority&gt; authorities; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; if(authorities!=null)&#123; return authorities; &#125; //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中 authorities = permissions.stream(). map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); return authorities; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; ​ LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。 package com.sangeng.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;import com.sangeng.domain.LoginUser;import com.sangeng.domain.User;import com.sangeng.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Objects;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //TODO 根据用户查询权限信息 添加到LoginUser中 List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;)); return new LoginUser(user,list); &#125;&#125; 3.2.3 从数据库查询权限信息3.2.3.1 RBAC权限模型​ RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。 ​ 3.2.3.2 准备工作CREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;USE `sg_security`;/*Table structure for table `sys_menu` */DROP TABLE IF EXISTS `sys_menu`;CREATE TABLE `sys_menu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `menu_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;菜单名&#x27;, `path` varchar(200) DEFAULT NULL COMMENT &#x27;路由地址&#x27;, `component` varchar(255) DEFAULT NULL COMMENT &#x27;组件路径&#x27;, `visible` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0显示 1隐藏）&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0正常 1停用）&#x27;, `perms` varchar(100) DEFAULT NULL COMMENT &#x27;权限标识&#x27;, `icon` varchar(100) DEFAULT &#x27;#&#x27; COMMENT &#x27;菜单图标&#x27;, `create_by` bigint(20) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(20) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `del_flag` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;是否删除（0未删除 1已删除）&#x27;, `remark` varchar(500) DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;菜单表&#x27;;/*Table structure for table `sys_role` */DROP TABLE IF EXISTS `sys_role`;CREATE TABLE `sys_role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(128) DEFAULT NULL, `role_key` varchar(100) DEFAULT NULL COMMENT &#x27;角色权限字符串&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;角色状态（0正常 1停用）&#x27;, `del_flag` int(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;del_flag&#x27;, `create_by` bigint(200) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(200) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `remark` varchar(500) DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;角色表&#x27;;/*Table structure for table `sys_role_menu` */DROP TABLE IF EXISTS `sys_role_menu`;CREATE TABLE `sys_role_menu` ( `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#x27;角色ID&#x27;, `menu_id` bigint(200) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单id&#x27;, PRIMARY KEY (`role_id`,`menu_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;/*Table structure for table `sys_user` */DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;, `nick_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;, `password` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;, `email` varchar(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `phonenumber` varchar(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `sex` char(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;, `avatar` varchar(128) DEFAULT NULL COMMENT &#x27;头像&#x27;, `user_type` char(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;, `create_by` bigint(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;, `create_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_by` bigint(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `update_time` datetime DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;;/*Table structure for table `sys_user_role` */DROP TABLE IF EXISTS `sys_user_role`;CREATE TABLE `sys_user_role` ( `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27;, `role_id` bigint(200) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;角色id&#x27;, PRIMARY KEY (`user_id`,`role_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; SELECT DISTINCT m.`perms`FROM sys_user_role ur LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id` LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id` LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`WHERE user_id = 2 AND r.`status` = 0 AND m.`status` = 0 package com.sangeng.domain;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import com.fasterxml.jackson.annotation.JsonInclude;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.Date;/** * 菜单表(Menu)实体类 * * @author makejava * @since 2021-11-24 15:30:08 */@TableName(value=&quot;sys_menu&quot;)@Data@AllArgsConstructor@NoArgsConstructor@JsonInclude(JsonInclude.Include.NON_NULL)public class Menu implements Serializable &#123; private static final long serialVersionUID = -54979041104113736L; @TableId private Long id; /** * 菜单名 */ private String menuName; /** * 路由地址 */ private String path; /** * 组件路径 */ private String component; /** * 菜单状态（0显示 1隐藏） */ private String visible; /** * 菜单状态（0正常 1停用） */ private String status; /** * 权限标识 */ private String perms; /** * 菜单图标 */ private String icon; private Long createBy; private Date createTime; private Long updateBy; private Date updateTime; /** * 是否删除（0未删除 1已删除） */ private Integer delFlag; /** * 备注 */ private String remark;&#125; 3.2.3.3 代码实现​ 我们只需要根据用户id去查询到其所对应的权限信息即可。 ​ 所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。 import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.sangeng.domain.Menu;import java.util.List;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */public interface MenuMapper extends BaseMapper&lt;Menu&gt; &#123; List&lt;String&gt; selectPermsByUserId(Long id);&#125; ​ 尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sangeng.mapper.MenuMapper&quot;&gt; &lt;select id=&quot;selectPermsByUserId&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT DISTINCT m.`perms` FROM sys_user_role ur LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id` LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id` LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id` WHERE user_id = #&#123;userid&#125; AND r.`status` = 0 AND m.`status` = 0 &lt;/select&gt;&lt;/mapper&gt; ​ 在application.yml中配置mapperXML文件的位置 spring: datasource: url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver redis: host: localhost port: 6379mybatis-plus: mapper-locations: classpath*:/mapper/**/*.xml ​ 然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Autowired private MenuMapper menuMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; List&lt;String&gt; permissionKeyList = menuMapper.selectPermsByUserId(user.getId());// //测试写法// List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;)); return new LoginUser(user,permissionKeyList); &#125;&#125; 4. 自定义失败处理​ 我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。 ​ 在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。 ​ 如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。 ​ 如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。 ​ 所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。 ①自定义实现类 @Componentpublic class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), &quot;权限不足&quot;); String json = JSON.toJSONString(result); WebUtils.renderString(response,json); &#125;&#125; /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Componentpublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), &quot;认证失败请重新登录&quot;); String json = JSON.toJSONString(result); WebUtils.renderString(response,json); &#125;&#125; ②配置给SpringSecurity ​ ​ 先注入对应的处理器 @Autowiredprivate AuthenticationEntryPoint authenticationEntryPoint;@Autowiredprivate AccessDeniedHandler accessDeniedHandler; ​ 然后我们可以使用HttpSecurity对象的方法去配置。 http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint). accessDeniedHandler(accessDeniedHandler); 5. 跨域​ 浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 ​ 前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。 ​ 所以我们就要处理一下，让前端能进行跨域请求。 ①先对SpringBoot配置，运行跨域请求 @Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; // 设置允许跨域的路径 registry.addMapping(&quot;/**&quot;) // 设置允许跨域请求的域名 .allowedOriginPatterns(&quot;*&quot;) // 是否允许cookie .allowCredentials(true) // 设置允许的请求方式 .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;) // 设置允许的header属性 .allowedHeaders(&quot;*&quot;) // 跨域允许时间 .maxAge(3600); &#125;&#125; ②开启SpringSecurity的跨域访问 由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。 @Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //添加过滤器 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); //配置异常处理器 http.exceptionHandling() //配置认证失败处理器 .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler); //允许跨域 http.cors();&#125; 6. 遗留小问题其它权限校验方法​ 我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。 ​ ​ 这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。 ​ hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。 ​ 它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。 ​ hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。 @PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;,&#x27;test&#x27;,&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; ​ hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 @PreAuthorize(&quot;hasRole(&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; ​ hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 @PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; 自定义权限校验方法​ 我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。 @Component(&quot;ex&quot;)public class SGExpressionRoot &#123; public boolean hasAuthority(String authority)&#123; //获取当前用户的权限 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); List&lt;String&gt; permissions = loginUser.getPermissions(); //判断用户权限集合中是否存在authority return permissions.contains(authority); &#125;&#125; ​ 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法 @RequestMapping(&quot;/hello&quot;)@PreAuthorize(&quot;@ex.hasAuthority(&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; 基于配置的权限控制​ 我们也可以在配置类中使用使用配置的方式对资源进行权限控制。 @Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() .antMatchers(&quot;/testCors&quot;).hasAuthority(&quot;system:dept:list222&quot;) // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //添加过滤器 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); //配置异常处理器 http.exceptionHandling() //配置认证失败处理器 .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler); //允许跨域 http.cors();&#125; CSRF​ CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。 ​ https://blog.csdn.net/freeking101/article/details/86537087 ​ SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。 ​ 我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。 认证成功处理器​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。 ​ 我们也可以自己去自定义成功处理器进行成功后的相应处理。 @Componentpublic class SGSuccessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println(&quot;认证成功了&quot;); &#125;&#125; @Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin().successHandler(successHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 认证失败处理器​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。 ​ 我们也可以自己去自定义失败处理器进行失败后的相应处理。 @Componentpublic class SGFailureHandler implements AuthenticationFailureHandler &#123; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; System.out.println(&quot;认证失败了&quot;); &#125;&#125; @Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// 配置认证成功处理器 .successHandler(successHandler)// 配置认证失败处理器 .failureHandler(failureHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 登出成功处理器@Componentpublic class SGLogoutSuccessHandler implements LogoutSuccessHandler &#123; @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println(&quot;注销成功&quot;); &#125;&#125; @Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Autowired private LogoutSuccessHandler logoutSuccessHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// 配置认证成功处理器 .successHandler(successHandler)// 配置认证失败处理器 .failureHandler(failureHandler); http.logout() //配置注销成功处理器 .logoutSuccessHandler(logoutSuccessHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 其他认证方案畅想7. 源码讲解​ 投票过50更新源码讲解"},{"title":"","date":"2023-04-13T08:07:24.870Z","updated":"2023-04-13T08:07:24.852Z","comments":true,"path":"notes/elasticsearch.html","permalink":"https://aqu.iyunmc.cn/notes/elasticsearch","excerpt":"","text":"elasticsearch什么是elasticsearch？ 一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能 什么是elastic stack（ELK）？ 是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch 什么是Lucene？ 是Apache的开源搜索引擎类库，提供了搜索引擎的核心API 正向索引和倒排索引什么是文档和词条？ 每一条数据就是一个文档 对文档中的内容分词，得到的词语就是词条 什么是正向索引？ 基于文档id创建索引，查询词条时必须先找到文档，而后判断是否包含词条 什么是倒排索引？ 对文档内容分词，对词条创建索引，并记录词条所在文档的信息 查询时先根据词条查询到文档id，而后获取到文档 elasticsearch与数据库的关系 数据库负责事务类型操作 elasticsearch负责海量数据的搜索、fen&#39;xi"},{"title":"","date":"2023-06-04T12:03:46.840Z","updated":"2023-06-04T12:03:46.840Z","comments":true,"path":"notes/安装elasticsearch.html","permalink":"https://aqu.iyunmc.cn/notes/%E5%AE%89%E8%A3%85elasticsearch","excerpt":"","text":"安装elasticsearch1.部署单点es1.1.创建网络因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络： docker network create es-net 1.2.加载镜像这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。 课前资料提供了镜像的tar包： 大家将其上传到虚拟机中，然后运行命令加载即可： # 导入数据docker load -i es.tar 同理还有kibana的tar包也需要这样做。 1.3.运行运行docker命令，部署单点es： docker run -d \\ --name es \\ -e &quot;ES_JAVA_OPTS=-Xms128m -Xmx256m&quot; \\ -e &quot;discovery.type=single-node&quot; \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\elasticsearch:7.12.1 命令解释： -e &quot;cluster.name=es-docker-cluster&quot;：设置集群名称 -e &quot;http.host=0.0.0.0&quot;：监听的地址，可以外网访问 -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;：内存大小 -e &quot;discovery.type=single-node&quot;：非集群模式 -v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录 -v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录 -v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录 --privileged：授予逻辑卷访问权 --network es-net ：加入一个名为es-net的网络中 -p 9200:9200：端口映射配置 在浏览器中输入：http://192.168.150.101:9200 即可看到elasticsearch的响应结果： 2.部署kibanakibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。 2.1.部署运行docker命令，部署kibana docker run -d \\--name kibana \\-e ELASTICSEARCH_HOSTS=http://es:9200 \\--network=es-net \\-p 5601:5601 \\kibana:7.10.1 --network es-net ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中 -e ELASTICSEARCH_HOSTS=http://es:9200&quot;：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch -p 5601:5601：端口映射配置 kibana启动一般比较慢，需要多等待一会，可以通过命令： docker logs -f kibana 查看运行日志，当查看到下面的日志，说明成功： 此时，在浏览器输入地址访问：http://192.168.150.101:5601，即可看到结果 2.2.DevToolskibana中提供了一个DevTools界面： 这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。 3.安装IK分词器3.1.在线安装ik插件（较慢）# 进入容器内部docker exec -it elasticsearch /bin/bash# 在线下载并安装./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip#退出exit#重启容器docker restart elasticsearch 3.2.离线安装ik插件（推荐）1）查看数据卷目录安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看: docker volume inspect es-plugins 显示结果： [ &#123; &quot;CreatedAt&quot;: &quot;2022-05-06T10:06:34+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/es-plugins/_data&quot;, &quot;Name&quot;: &quot;es-plugins&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125;] 说明plugins目录被挂载到了：/var/lib/docker/volumes/es-plugins/_data 这个目录中。 2）解压缩分词器安装包下面我们需要把课前资料中的ik分词器解压缩，重命名为ik 3）上传到es容器的插件数据卷中也就是/var/lib/docker/volumes/es-plugins/_data ： 4）重启容器# 4、重启容器docker restart es # 查看es日志docker logs -f es 5）测试：IK分词器包含两种模式： ik_smart：最少切分 ik_max_word：最细切分 GET /_analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;黑马程序员学习java太棒了&quot;&#125; 结果： &#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;黑马&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;程序员&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;程序&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;员&quot;, &quot;start_offset&quot; : 4, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 3 &#125;, &#123; &quot;token&quot; : &quot;学习&quot;, &quot;start_offset&quot; : 5, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 4 &#125;, &#123; &quot;token&quot; : &quot;java&quot;, &quot;start_offset&quot; : 7, &quot;end_offset&quot; : 11, &quot;type&quot; : &quot;ENGLISH&quot;, &quot;position&quot; : 5 &#125;, &#123; &quot;token&quot; : &quot;太棒了&quot;, &quot;start_offset&quot; : 11, &quot;end_offset&quot; : 14, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 6 &#125;, &#123; &quot;token&quot; : &quot;太棒&quot;, &quot;start_offset&quot; : 11, &quot;end_offset&quot; : 13, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 7 &#125;, &#123; &quot;token&quot; : &quot;了&quot;, &quot;start_offset&quot; : 13, &quot;end_offset&quot; : 14, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 8 &#125; ]&#125; 3.3 扩展词词典随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“传智播客” 等。 所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。 1）打开IK分词器config目录： 2）在IKAnalyzer.cfg.xml配置文件内容添加： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;&lt;/properties&gt; 3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改 传智播客奥力给 4）重启elasticsearch docker restart es# 查看 日志docker logs -f elasticsearch 日志中已经成功加载ext.dic配置文件 5）测试效果： GET /_analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;传智播客Java就业超过90%,奥力给！&quot;&#125; 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 3.4 停用词词典在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。 IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。 1）IKAnalyzer.cfg.xml配置文件内容添加： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典--&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt; &lt;!--用户可以在这里配置自己的扩展停止词字典 *** 添加停用词词典--&gt; &lt;entry key=&quot;ext_stopwords&quot;&gt;stopword.dic&lt;/entry&gt;&lt;/properties&gt; 3）在 stopword.dic 添加停用词 习大大 4）重启elasticsearch # 重启服务docker restart elasticsearchdocker restart kibana# 查看 日志docker logs -f elasticsearch 日志中已经成功加载stopword.dic配置文件 5）测试效果： GET /_analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;传智播客Java就业率超过95%,习大大都点赞,奥力给！&quot;&#125; 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 4.部署es集群部署es集群可以直接使用docker-compose来完成，不过要求你的Linux虚拟机至少有4G的内存空间 首先编写一个docker-compose文件，内容如下： version: &#x27;2.2&#x27;services: es01: image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster - discovery.seed_hosts=es02,es03 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data01:/usr/share/elasticsearch/data ports: - 9200:9200 networks: - elastic es02: image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1 container_name: es02 environment: - node.name=es02 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es03 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data02:/usr/share/elasticsearch/data networks: - elastic es03: image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1 container_name: es03 environment: - node.name=es03 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es02 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data03:/usr/share/elasticsearch/data networks: - elasticvolumes: data01: driver: local data02: driver: local data03: driver: localnetworks: elastic: driver: bridge Run docker-compose to bring up the cluster: docker-compose up"},{"title":"","date":"2023-06-04T11:49:18.140Z","updated":"2023-06-04T11:49:18.140Z","comments":true,"path":"notes/index.html","permalink":"https://aqu.iyunmc.cn/notes/","excerpt":"","text":""},{"title":"","date":"2023-05-31T09:01:21.418Z","updated":"2023-05-31T09:00:14.119Z","comments":true,"path":"notes/网关的作用.html","permalink":"https://aqu.iyunmc.cn/notes/%E7%BD%91%E5%85%B3%E7%9A%84%E4%BD%9C%E7%94%A8","excerpt":"","text":"1. 网关的作用 对用户请求做身份认证、权限校验 将用户请求路由到微服务，并实现负载均衡 对用户请求做限流 2. 搭建网关服务网关搭建步骤 创建项目，引入nacos服务发现和gateway依赖 &lt;dependencies&gt; &lt;!-- nacos服务注册发现依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 网关gateway依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置application.yml，包括服务基本信息、nacos地址、路由 application: name: gatewaycloud: nacos: server-addr: localhost:8848 gateway: routes: - id: user-service # 路由表必须是唯一的 uri: lb://userservice # 路由的目标地址 predicates: # 路由断言，判断请求是否符合规则 - Path=/user/** #路径断言，判断路径是否以/user开头 - id: order-service uri: lb://orderservice predicates: - Path=/order/** 3. 过滤器工厂过滤器的作用是什么？ 对路由的请求或响应做加工处理，比如添加请求头 配置在路由下的过滤器只对当前路由的请求生效 defaultFilters的作用是什么？ 对所有路由都生效的过滤器 4. 全局过滤器全局过滤器的作用 对所有路由都生效的过滤器，并且可以自定义处理逻辑 实现全局过滤器的步骤 实现GlobalFilter接口 添加@Order注解或实现Ordered接口 编写处理逻辑 @Order(-1)@Componentpublic class AuthorizeFilter implements GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; // 1.获取请求参数 ServerHttpRequest request = exchange.getRequest(); MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams(); // 2.获取参数中的authorization参数 String auth = queryParams.getFirst(&quot;authorization&quot;); // 3.判断参数值是否等于admin if (&quot;admin&quot;.equals(auth)) &#123; // 4.是，放行 return chain.filter(exchange); &#125; // 5.否，拦截 // 5.1 设置状态码 exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); // 5.2 拦截请求 return exchange.getResponse().setComplete(); &#125;&#125; 5. 过滤器执行顺序 每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前。 GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定 路由过滤器和defaultFilter的order由Spring指定，默认是按照生命顺序从1递增 当过滤器的order值一样时，会按照defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行"},{"title":"","date":"2023-06-04T11:56:20.125Z","updated":"2023-06-04T11:56:20.125Z","comments":true,"path":"notes/面试1.html","permalink":"https://aqu.iyunmc.cn/notes/%E9%9D%A2%E8%AF%951","excerpt":"","text":"RedisRedis的数据持久化策略有哪些？我看你做的项目中，都用到了redis，你在项目中给你那些场景使用了Redis呢？如果发生了缓存穿透、击穿、雪崩如何解决呢？缓存穿透： 查询一个不存在的数据，mysql中也查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库 解决方案： 方案一：缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存（消耗内存，可能会发送不一致的问题） 方案二：布隆过滤器：当根据id查询时 缓存击穿：给某一个key设置了过期时间，当key过期时，恰好在这个时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把DB压垮 解决方案： 方案一：互斥锁，强一致，性能差 方案二：逻辑过期，高可用，性能优，不能保证数据绝对一致 缓存雪崩：指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，给DB带来巨大压力 解决方案： 给不同的Key的TTL添加随机值 利用Redis集群提高服务的可用性（哨兵模式、集群模式） 给缓存业务添加降级限流策略（Nginx、SpringCloud Gateway） 给业务添加多级缓存（Guava&#x2F;Caffeine） 会被问到的知识点：Redis作为缓存，mysql的数据如何与redis进行同步呢？（双写一致性） 我当时是把题库论坛的热点数据存到了缓存当中，虽然是热点数据，但是实时要求性并没有那么高，所以我当时采用的是异步的方案同步的数据 还有就是抢卷的库存写入到了缓存当中，这个需要实时的进行数据同步，为了保证数据的强一致性，我们当时采用的是Redisson提供的读写锁来保证数据的同步 那你介绍一下你项目当中异步的方案（来介绍一下redisson读写锁的这种方案） 允许延时一致的业务，采用异步通知 使用MQ中间件，更新数据之后，通知缓存删除 利用canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canal通过读取binlog数据更新缓存 强一致性的，采用Redisson提供的读写锁 共享锁：读锁readLock，加锁之后，其他线程可以共享读操作 排他锁：独占锁writeLock，枷锁之后，阻塞其他线程读写操作 Redis持久化redis作为缓存，数据的持久化是如何做的？Redis提供了两种数据持久化的方式： RDB（Redis Database ）：RDB是一个快照文件，他是把Redis内存存储的数据写到磁盘当中，当redis实例宕机恢复数据时，可以从rdb的快照文件中恢复数据。 AOF：AOF是一个追加文件，当redis操作写命令的时候，都会存储到这个文件当中，当redis实例宕机恢复数据的时候会从这个文件中再次执行一遍命令来恢复数据。 这两种方式，哪种恢复的比较快呢？1RDB是二进制文件，在保存的时候体积也是比较小的，他会封得比较快，但是有可能会丢失数据，而我们通常在项目中使用AOF来恢复数据，虽然AOF恢复的速度慢一些，但是他丢数据的奉孝要小很多，在AOF文件中可以设置刷盘策略 Redis数据删除策略惰性删除：设置该key过期时间后，我们不去管他，当需要该key时，我们再检查其是否过期，如果过期，我们就删掉他，反之则返回该key 优点：对cpu友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。 缺点：对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存当中，内存永远不会释放 定期删除：每隔一段时间，就会对一些key进行检查，删除里面过期的key（从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key） 优点：可以通过限制删除操作执行的时长和频率来减少删除操作对cpu的影响，另外定期删除，也能有效释放过期key占用的内存。 缺点：难以确定删除操作执行的时长和频率 Redis数据淘汰策略 LRU（Least Recently Used）最近最少使用，用当前的时间减去最后一次使用的时间，值越大则淘汰优先级越高 LFU（Least Frequently Used）最少频率使用，会统计每个key的访问频率，值越小淘汰优先级越高 会被问到的知识点：数据库中有1000万数据，而Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？使用allkeys-lru（挑选最近最少使用的数据淘汰）淘汰策略，留下来的都是经常访问的热点数据 Redis的内存用完了会发生什么？主要看数据淘汰策略是什么？如果是默认的配置（noeviction）就会直接报错 面试官你好 今年xx岁"},{"title":"","date":"2023-06-06T14:16:10.675Z","updated":"2023-06-06T14:16:10.675Z","comments":true,"path":"notes/Kafka.html","permalink":"https://aqu.iyunmc.cn/notes/Kafka","excerpt":"","text":"1. Kafka简介1.1 消息队列 消息队列 -- 用于存放消息的组件 程序员可以将消息放入到队列当中，也可以从消息队列中获取消息 很多时候消息队列不是一个永久性的存储，是作为临时存储存在的（设定一个期限：设置消息在MQ中保存10天） 消息队列中间件：消息队列的组件，例如：Kafka、Active MQ、RabbitMQ、RocketMQ、 1.2 Kafka的应用场景 异步处理 可以将一些比较耗时的操作放在其他系统中，通过消息队列将需要进行处理的消息进行存储，其他系统可以消费消息队列中的数据 比较常见的：发送短信验证码、发送邮箱! 系统解耦 原先一个微服务是通过接口（HTTP）调用另一个微服务，这时候耦合很重要，只要接口发生变法就会导致系统不可用 使用消息队列可以将系统进行解耦合，现在第一个微服务可以将消息放入到消息队列中，另一个微服务可以从消息队列中把消息取出来处理，进行系统耦合 流量削峰 因为消息队列是低延迟、高可靠、高吞吐的，可以应对海量的并发 日志处理 可以使用消息队列作为临时存储，或者一种通信管道 1.3 Kafka的应用场景 生产者、消费者模型 生产者负责将消息生产到MQ中 消费者负责从MQ中获取消息 生产者和消费者是解耦的，可能是生产者一个程序、消费者是另外一个程序 消息队列的模式 点对点：一个消费者消费一个消息 发布订阅：多个消费者可以消费一个消息 2. 环境搭建2.1 搭建Kafka集群2.1.1 下载kafka两种方式（1）手动下载 下载地址：Apache Kafka （2）也可以用命令下载（直接下载到服务器哦！）： ​ 将安装包下载到&#x2F;opt&#x2F;monitor&#x2F;kafka文件夹下面​ 下载命令：​ wget http://mirrors.hust.edu.cn/apache/kafka/2.0.0/kafka_2.12-2.0.0.tgz​ 手动下载移动到&#x2F;opt&#x2F;monitor&#x2F;kafka目录下也可 2.1.2 解压Kafkatar -xvzf kafka_2.12-2.5.1.tgz -C ../server/ 2.1.3 修改server.properties文件 2.1.4 配置KAFKA_HOME环境变量vim /etc/profileexport KAFKA_HOME=/export/server/kafka_2.12-2.4.1export PATH=:$PATH:$&#123;KAFKA_HOME&#125;分发到各个节点scp /etc/profile node2.itcast.cn:$PWDscp /etc/profile node3.itcast.cn:$PWD每个节点加载环境变量source /etc/profile 2.1.5 启动服务器# 启动ZooKeepernohup bin/zookeeper-server-start.sh config/zookeeper.properties &amp;# 启动Kafkacd /export/server/kafka_2.12-2.4.1nohup bin/kafka-server-start.sh config/server.properties &amp;# 测试Kafka集群是否启动成功bin/kafka-topics.sh --bootstrap-server 8.130.95.129:9092 --list 2.2 目录结构分析 目录名称 说明 bin Kafka的所有执行脚本都在这里。例如：启动Kafka服务器、创建Topic、生产者、消费者程序等等 config Kafka的所有配置文件 libs 运行Kafka所需要的所有JAR包 logs Kafka的所有日志文件，如果Kafka出现一些问题，需要到该目录中去查看异常信息 site-docs Kafka的网站帮助文件 2.3 Kafka一键启动&#x2F;关闭脚本为了方便将来进行一键启动、关闭Kafka，我们可以编写一个shell脚本来操作。将来只要执行一次该脚本就可以快速启动&#x2F;关闭Kafka。 在节点1中创建 &#x2F;export&#x2F;onekey 目录 cd &#x2F;export&#x2F;onekey 准备slave配置文件，用于保存要启动哪几个节点上的kafka 8.130.95.129node2.itcast.cnnode3.itcast.cn 编写start-kafka.sh脚本 vim start-kafka.shcat /export/onekey/slave | while read linedo&#123; echo $line ssh $line &quot;source /etc/profile;export JMX_PORT=9988;nohup $&#123;KAFKA_HOME&#125;/bin/kafka-server-start.sh $&#123;KAFKA_HOME&#125;/config/server.properties &gt;/dev/nul* 2&gt;&amp;1 &amp; &quot;&#125;&amp;waitdone 编写stop-kafka.sh脚本 vim stop-kafka.shcat /export/onekey/slave | while read linedo&#123; echo $line ssh $line &quot;source /etc/profile;jps |grep Kafka |cut -d&#x27; &#x27; -f1 |xargs kill -s 9&quot;&#125;&amp;waitdone 给start-kafka.sh、stop-kafka.sh配置执行权限 chmod u+x start-kafka.shchmod u+x stop-kafka.sh 执行一键启动、一键关闭 ./start-kafka.sh./stop-kafka.sh 3. 创建topic3.1 创建创建一个topic（主题）。Kafka中所有的消息都是保存在主题中，要生产消息到Kafka，首先必须要有一个确定的主题。 # 创建名为test的主题bin/kafka-topics.sh --create --bootstrap-server 8.130.95.129:9092 --topic test# 查看目前Kafka中的主题bin/kafka-topics.sh --list --bootstrap-server 8.130.95.129:9092 3.2 生产消息到Kafka使用Kafka内置的测试程序，生产一些消息到Kafka的test主题中。 bin/kafka-console-producer.sh --broker-list 8.130.95.129:9092 --topic test 3.3 从Kafka消费消息使用下面的命令来消费 test 主题中的消息。 bin/kafka-console-consumer.sh --bootstrap-server 8.130.95.129:9092 --topic test --from-beginning 4. Kafka集群搭建 Kafka集群是必须要有ZooKeeper的 注意： 每一个Kafka的节点都需要修改broker.id（每个结点的标识不能重复） log.dir数据存储目录需要配置 4.1 Kafka的生产者&#x2F;消费者&#x2F;工具 安装Kafka集群，可以测试一下 创建一个topic主题（消息都是存放在topic中，类似mysql建表的过程） 基于Kafka的内置测试生产者脚本来读取标准输入（键盘输入）的数据，并放入到topic中 基于Kafka的内置测试消费者脚本来消费topic中的数据 Kafka Tool 浏览Kafka集群节点、多少个topic、多少个分区 创建topic&#x2F;删除topic 浏览ZooKeeper中的数据 4.2 Kafka的基准测试工具 Kafka中提供了内置的性能测试工具 生产者：测试生产每秒传输的数据条（多少条数据、多少M的数据） 消费者：测试消费每条拉去的数据量 对比生产者和消费者：消费者的速度更快"}],"posts":[{"title":"","slug":"blog/header","date":"2023-05-31T01:21:31.556Z","updated":"2023-06-04T12:57:25.074Z","comments":true,"path":"blog/header/","link":"","permalink":"https://aqu.iyunmc.cn/blog/header/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Redis面试必备","slug":"blog/面试1","date":"2023-05-20T11:50:00.000Z","updated":"2023-06-05T08:11:45.059Z","comments":true,"path":"blog/面试1/","link":"","permalink":"https://aqu.iyunmc.cn/blog/%E9%9D%A2%E8%AF%951/","excerpt":"RedisRedis的数据持久化策略有哪些？我看你做的项目中，都用到了redis，你在项目中给你那些场景使用了Redis呢？","text":"RedisRedis的数据持久化策略有哪些？我看你做的项目中，都用到了redis，你在项目中给你那些场景使用了Redis呢？ 如果发生了缓存穿透、击穿、雪崩如何解决呢？缓存穿透： 查询一个不存在的数据，mysql中也查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库 解决方案： 方案一：缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存（消耗内存，可能会发送不一致的问题） 方案二：布隆过滤器：当根据id查询时 缓存击穿：给某一个key设置了过期时间，当key过期时，恰好在这个时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把DB压垮 解决方案： 方案一：互斥锁，强一致，性能差 方案二：逻辑过期，高可用，性能优，不能保证数据绝对一致 缓存雪崩：指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，给DB带来巨大压力 解决方案： 给不同的Key的TTL添加随机值 利用Redis集群提高服务的可用性（哨兵模式、集群模式） 给缓存业务添加降级限流策略（Nginx、SpringCloud Gateway） 给业务添加多级缓存（Guava&#x2F;Caffeine） 会被问到的知识点：Redis作为缓存，mysql的数据如何与redis进行同步呢？（双写一致性） 我当时是把题库论坛的热点数据存到了缓存当中，虽然是热点数据，但是实时要求性并没有那么高，所以我当时采用的是异步的方案同步的数据 还有就是抢卷的库存写入到了缓存当中，这个需要实时的进行数据同步，为了保证数据的强一致性，我们当时采用的是Redisson提供的读写锁来保证数据的同步 那你介绍一下你项目当中异步的方案（来介绍一下redisson读写锁的这种方案） 允许延时一致的业务，采用异步通知 使用MQ中间件，更新数据之后，通知缓存删除 利用canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canal通过读取binlog数据更新缓存 强一致性的，采用Redisson提供的读写锁 共享锁：读锁readLock，加锁之后，其他线程可以共享读操作 排他锁：独占锁writeLock，枷锁之后，阻塞其他线程读写操作 Redis持久化redis作为缓存，数据的持久化是如何做的？Redis提供了两种数据持久化的方式： RDB（Redis Database ）：RDB是一个快照文件，他是把Redis内存存储的数据写到磁盘当中，当redis实例宕机恢复数据时，可以从rdb的快照文件中恢复数据。 AOF：AOF是一个追加文件，当redis操作写命令的时候，都会存储到这个文件当中，当redis实例宕机恢复数据的时候会从这个文件中再次执行一遍命令来恢复数据。 这两种方式，哪种恢复的比较快呢？1RDB是二进制文件，在保存的时候体积也是比较小的，他会封得比较快，但是有可能会丢失数据，而我们通常在项目中使用AOF来恢复数据，虽然AOF恢复的速度慢一些，但是他丢数据的奉孝要小很多，在AOF文件中可以设置刷盘策略 Redis数据删除策略惰性删除：设置该key过期时间后，我们不去管他，当需要该key时，我们再检查其是否过期，如果过期，我们就删掉他，反之则返回该key 优点：对cpu友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。 缺点：对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存当中，内存永远不会释放 定期删除：每隔一段时间，就会对一些key进行检查，删除里面过期的key（从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key） 优点：可以通过限制删除操作执行的时长和频率来减少删除操作对cpu的影响，另外定期删除，也能有效释放过期key占用的内存。 缺点：难以确定删除操作执行的时长和频率 Redis数据淘汰策略 LRU（Least Recently Used）最近最少使用，用当前的时间减去最后一次使用的时间，值越大则淘汰优先级越高 LFU（Least Frequently Used）最少频率使用，会统计每个key的访问频率，值越小淘汰优先级越高 会被问到的知识点：数据库中有1000万数据，而Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？使用allkeys-lru（挑选最近最少使用的数据淘汰）淘汰策略，留下来的都是经常访问的热点数据 Redis的内存用完了会发生什么？主要看数据淘汰策略是什么？如果是默认的配置（noeviction）就会直接报错 面试官你好 今年xx岁","categories":[{"name":"面试","slug":"面试","permalink":"https://aqu.iyunmc.cn/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Redis","slug":"redis","permalink":"https://aqu.iyunmc.cn/tags/redis/"}]},{"title":"网关GateWay","slug":"blog/网关的作用","date":"2023-04-07T11:50:00.000Z","updated":"2023-06-04T12:59:07.553Z","comments":true,"path":"blog/网关的作用/","link":"","permalink":"https://aqu.iyunmc.cn/blog/%E7%BD%91%E5%85%B3%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"1. 网关的作用 对用户请求做身份认证、权限校验 将用户请求路由到微服务，并实现负载均衡 对用户请求做限流 2. 搭建网关服务","text":"1. 网关的作用 对用户请求做身份认证、权限校验 将用户请求路由到微服务，并实现负载均衡 对用户请求做限流 2. 搭建网关服务 网关搭建步骤 创建项目，引入nacos服务发现和gateway依赖 &lt;dependencies&gt; &lt;!-- nacos服务注册发现依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 网关gateway依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置application.yml，包括服务基本信息、nacos地址、路由 application: name: gatewaycloud: nacos: server-addr: localhost:8848 gateway: routes: - id: user-service # 路由表必须是唯一的 uri: lb://userservice # 路由的目标地址 predicates: # 路由断言，判断请求是否符合规则 - Path=/user/** #路径断言，判断路径是否以/user开头 - id: order-service uri: lb://orderservice predicates: - Path=/order/** 3. 过滤器工厂过滤器的作用是什么？ 对路由的请求或响应做加工处理，比如添加请求头 配置在路由下的过滤器只对当前路由的请求生效 defaultFilters的作用是什么？ 对所有路由都生效的过滤器 4. 全局过滤器全局过滤器的作用 对所有路由都生效的过滤器，并且可以自定义处理逻辑 实现全局过滤器的步骤 实现GlobalFilter接口 添加@Order注解或实现Ordered接口 编写处理逻辑 @Order(-1)@Componentpublic class AuthorizeFilter implements GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; // 1.获取请求参数 ServerHttpRequest request = exchange.getRequest(); MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams(); // 2.获取参数中的authorization参数 String auth = queryParams.getFirst(&quot;authorization&quot;); // 3.判断参数值是否等于admin if (&quot;admin&quot;.equals(auth)) &#123; // 4.是，放行 return chain.filter(exchange); &#125; // 5.否，拦截 // 5.1 设置状态码 exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); // 5.2 拦截请求 return exchange.getResponse().setComplete(); &#125;&#125; 5. 过滤器执行顺序 每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前。 GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定 路由过滤器和defaultFilter的order由Spring指定，默认是按照生命顺序从1递增 当过滤器的order值一样时，会按照defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行","categories":[{"name":"教程","slug":"教程","permalink":"https://aqu.iyunmc.cn/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://aqu.iyunmc.cn/tags/java/"}]},{"title":"「Docker」基本命令","slug":"blog/Docker","date":"2023-03-25T08:43:21.000Z","updated":"2023-06-04T12:38:49.093Z","comments":true,"path":"blog/Docker/","link":"","permalink":"https://aqu.iyunmc.cn/blog/Docker/","excerpt":"","text":"DockerDocker是一个快速交付应用、运行应用的技术 可以将程序机器依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统 运行时利用沙箱机制形成隔离容器，各个应用互不干扰 启动、移除都可以通过一行命令完成，方便快捷 镜像：将应用及其依赖、环境、配置打包在一起 容器：镜像运行起来就是容器，一个镜像可以运行多个容器 Docker结构：服务端：接受命令或远程请求，操作镜像或容器 客户端：发送命令或者请求到Docker服务端 Docker基本操作-镜像1.基本操作docker images 查看镜像 docker rmi 删除指定镜像 docker pull 拉取镜像 docker push 推送镜像 docker save 保存镜像tar docker load 加载tar镜像 docker ps 查看所有运行的容器及状态 docker rm 删除容器（不能删除运行中的容器，除非添加 -f 参数） docker logs 查看容器运行日志 docker exec -it [容器名] [要执行的命令] 进入容器执行命令 2.容器命令①.创建运行一个Nginx容器步骤一：去docker hub查看Nginx的容器运行命令 docker run --name containerName -p 80:80 -d nginx 命令解读： docker run：创建并运行一个容器 --name：给容器起一个名字，比如叫做ng -p：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口 -d：后台运行容器 nginx：镜像名称，例如nginx docker run命令的常见参数 --name：指定容器名称 -p：指定端口映射 -d：让容器后台运行 查看容器日志的命令docker logs 添加 -f 参数可以持续查看日志 查看容器状态docker ps 2.1 进入Nginx容器，修改HTML文件内容，添加“Ino欢迎你”步骤一：进入容器docker exec -it mn bash 命令解读： docker exec：进入容器内部，执行一个命令 -it：给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 mn：要进入的容器的名称 bash：进入容器后执行的命令，bash是一个linux终端交互命令 ②.操作数据卷数据卷的作用： 将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全 docker volume [COMMAND] docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作： create 创建一个volume inspect 显示一个或多个volume的信息 ls 列出所有的volume prune 删除未使用的volume rm 删除一个或多个指定的volume 创建数据卷 docker volume craete html 2.查看所有数据 docker volume ls 3.查看数据卷详细信息卷 docker volume inspect html 2.2 利用数据卷操作nginx容器① 创建容器并挂载数据卷到容器内的HTML目录 docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx ② 进入html数据卷所在位置，并修改HTML内容 # 查看html数据卷的位置docker volume inspect html# 进入该目录cd /var/lib/docker/volumes/html/_data# 修改文件vi index.html 2.3 创建并运行一个MySQL容器，将宿主机目录直接挂载到容器提示:目录挂载与数据卷挂载的语法是类似的: -v[宿主机目录]:[容器内目录] -v[宿主机文件]:[容器内文件] 实现思路如下: 1．在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像 2．创建目录&#x2F;tmp&#x2F;myql&#x2F;data 3．创建目录&#x2F;tmp&#x2F;myql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tmp&#x2F;myql&#x2F;conf 4．去DockerHub查阅资料，创建并运行MySQL容器，要求: 挂载&#x2F;tmp&#x2F;myql&#x2F;data到mysql容器内数据存储目录 挂载&#x2F;tmp&#x2F;myql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件 设置MySQL密码 docker run --name mysql -e MYSQL_ROOT_PASSWORD=adg153 -p 3307:3306 -v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf -v /tmp/mysql/data:/var/lib/mysql -d mysql:5.7.25 自定义镜像 - 镜像结构竟像是分层结构，每一层成为一个Layer（层） BaseImage层：包含基本的系统函数库、环境变量、文件系统 Entrypoint：入口，是镜像中应用启动的命令（systemctl start mysql.service） 其他：在BaseImage基础上添加依赖、安装程序、完成整个应用的安装和配置 2.CentOS7安装DockerCompose2.1.下载Linux下需要通过命令下载： # 安装curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件： 上传到/usr/local/bin/目录也可以。 2.2.修改文件权限修改文件权限： # 修改权限chmod +x /usr/local/bin/docker-compose 2.3.Base自动补全命令：# 补全命令curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 如果这里出现错误，需要修改自己的hosts文件： echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts 3.Docker镜像仓库搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。 官网地址：https://hub.docker.com/_/registry 3.1.简化版镜像仓库Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。 搭建方式比较简单，命令如下： docker run -d \\ --restart=always \\ --name registry \\ -p 5000:5000 \\ -v registry-data:/var/lib/registry \\ registry 命令中挂载了一个数据卷registry-data到容器内的&#x2F;var&#x2F;lib&#x2F;registry 目录，这是私有镜像库存放数据的目录。 访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像 3.2.带有图形化界面版本使用DockerCompose部署带有图象界面的DockerRegistry，命令如下： version: &#x27;3.0&#x27;services: registry: image: registry volumes: - ./registry-data:/var/lib/registry ui: image: joxit/docker-registry-ui:static ports: - 8080:80 environment: - REGISTRY_TITLE=传智教育私有仓库 - REGISTRY_URL=http://registry:5000 depends_on: - registry 3.3.配置Docker信任地址我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置： # 打开要修改的文件vi /etc/docker/daemon.json# 添加内容：&quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;]# 重加载systemctl daemon-reload# 重启dockersystemctl restart docker","categories":[{"name":"教程","slug":"教程","permalink":"https://aqu.iyunmc.cn/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://aqu.iyunmc.cn/tags/linux/"}]},{"title":"安装Elasticsearch","slug":"blog/安装elasticsearch","date":"2023-03-20T11:50:00.000Z","updated":"2023-06-04T12:42:28.843Z","comments":true,"path":"blog/安装elasticsearch/","link":"","permalink":"https://aqu.iyunmc.cn/blog/%E5%AE%89%E8%A3%85elasticsearch/","excerpt":"","text":"安装elasticsearch1.部署单点es1.1.创建网络因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络： docker network create es-net 1.2.加载镜像这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。 课前资料提供了镜像的tar包： 大家将其上传到虚拟机中，然后运行命令加载即可： # 导入数据docker load -i es.tar 同理还有kibana的tar包也需要这样做。 1.3.运行运行docker命令，部署单点es： docker run -d \\ --name es \\ -e &quot;ES_JAVA_OPTS=-Xms128m -Xmx256m&quot; \\ -e &quot;discovery.type=single-node&quot; \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\elasticsearch:7.12.1 命令解释： -e &quot;cluster.name=es-docker-cluster&quot;：设置集群名称 -e &quot;http.host=0.0.0.0&quot;：监听的地址，可以外网访问 -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;：内存大小 -e &quot;discovery.type=single-node&quot;：非集群模式 -v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录 -v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录 -v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录 --privileged：授予逻辑卷访问权 --network es-net ：加入一个名为es-net的网络中 -p 9200:9200：端口映射配置 在浏览器中输入：http://192.168.150.101:9200 即可看到elasticsearch的响应结果： 2.部署kibanakibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。 2.1.部署运行docker命令，部署kibana docker run -d \\--name kibana \\-e ELASTICSEARCH_HOSTS=http://es:9200 \\--network=es-net \\-p 5601:5601 \\kibana:7.10.1 --network es-net ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中 -e ELASTICSEARCH_HOSTS=http://es:9200&quot;：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch -p 5601:5601：端口映射配置 kibana启动一般比较慢，需要多等待一会，可以通过命令： docker logs -f kibana 查看运行日志，当查看到下面的日志，说明成功： 此时，在浏览器输入地址访问：http://192.168.150.101:5601，即可看到结果 2.2.DevToolskibana中提供了一个DevTools界面： 这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。 3.安装IK分词器3.1.在线安装ik插件（较慢）# 进入容器内部docker exec -it elasticsearch /bin/bash# 在线下载并安装./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip#退出exit#重启容器docker restart elasticsearch 3.2.离线安装ik插件（推荐）1）查看数据卷目录安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看: docker volume inspect es-plugins 显示结果： [ &#123; &quot;CreatedAt&quot;: &quot;2022-05-06T10:06:34+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/es-plugins/_data&quot;, &quot;Name&quot;: &quot;es-plugins&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125;] 说明plugins目录被挂载到了：/var/lib/docker/volumes/es-plugins/_data 这个目录中。 2）解压缩分词器安装包下面我们需要把课前资料中的ik分词器解压缩，重命名为ik 3）上传到es容器的插件数据卷中也就是/var/lib/docker/volumes/es-plugins/_data ： 4）重启容器# 4、重启容器docker restart es # 查看es日志docker logs -f es 5）测试：IK分词器包含两种模式： ik_smart：最少切分 ik_max_word：最细切分 GET /_analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;黑马程序员学习java太棒了&quot;&#125; 结果： &#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;黑马&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;程序员&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;程序&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;员&quot;, &quot;start_offset&quot; : 4, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 3 &#125;, &#123; &quot;token&quot; : &quot;学习&quot;, &quot;start_offset&quot; : 5, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 4 &#125;, &#123; &quot;token&quot; : &quot;java&quot;, &quot;start_offset&quot; : 7, &quot;end_offset&quot; : 11, &quot;type&quot; : &quot;ENGLISH&quot;, &quot;position&quot; : 5 &#125;, &#123; &quot;token&quot; : &quot;太棒了&quot;, &quot;start_offset&quot; : 11, &quot;end_offset&quot; : 14, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 6 &#125;, &#123; &quot;token&quot; : &quot;太棒&quot;, &quot;start_offset&quot; : 11, &quot;end_offset&quot; : 13, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 7 &#125;, &#123; &quot;token&quot; : &quot;了&quot;, &quot;start_offset&quot; : 13, &quot;end_offset&quot; : 14, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 8 &#125; ]&#125; 3.3 扩展词词典随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“传智播客” 等。 所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。 1）打开IK分词器config目录： 2）在IKAnalyzer.cfg.xml配置文件内容添加： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;&lt;/properties&gt; 3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改 传智播客奥力给 4）重启elasticsearch docker restart es# 查看 日志docker logs -f elasticsearch 日志中已经成功加载ext.dic配置文件 5）测试效果： GET /_analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;传智播客Java就业超过90%,奥力给！&quot;&#125; 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 3.4 停用词词典在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。 IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。 1）IKAnalyzer.cfg.xml配置文件内容添加： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典--&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt; &lt;!--用户可以在这里配置自己的扩展停止词字典 *** 添加停用词词典--&gt; &lt;entry key=&quot;ext_stopwords&quot;&gt;stopword.dic&lt;/entry&gt;&lt;/properties&gt; 3）在 stopword.dic 添加停用词 习大大 4）重启elasticsearch # 重启服务docker restart elasticsearchdocker restart kibana# 查看 日志docker logs -f elasticsearch 日志中已经成功加载stopword.dic配置文件 5）测试效果： GET /_analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;传智播客Java就业率超过95%,习大大都点赞,奥力给！&quot;&#125; 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 4.部署es集群部署es集群可以直接使用docker-compose来完成，不过要求你的Linux虚拟机至少有4G的内存空间 首先编写一个docker-compose文件，内容如下： version: &#x27;2.2&#x27;services: es01: image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster - discovery.seed_hosts=es02,es03 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data01:/usr/share/elasticsearch/data ports: - 9200:9200 networks: - elastic es02: image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1 container_name: es02 environment: - node.name=es02 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es03 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data02:/usr/share/elasticsearch/data networks: - elastic es03: image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1 container_name: es03 environment: - node.name=es03 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es02 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data03:/usr/share/elasticsearch/data networks: - elasticvolumes: data01: driver: local data02: driver: local data03: driver: localnetworks: elastic: driver: bridge Run docker-compose to bring up the cluster: docker-compose up","categories":[{"name":"教程","slug":"教程","permalink":"https://aqu.iyunmc.cn/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://aqu.iyunmc.cn/tags/linux/"}]},{"title":"Ribbon负载均衡","slug":"blog/Ribbon负载均衡","date":"2023-03-12T16:00:00.000Z","updated":"2023-06-05T07:36:25.911Z","comments":true,"path":"blog/Ribbon负载均衡/","link":"","permalink":"https://aqu.iyunmc.cn/blog/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"1. Ribbon负载均衡规则","text":"1. Ribbon负载均衡规则 规则接口是IRule 默认实现是ZoneAvoidanceRule，根据zone选择服务列表，然后轮询 2. 负载均衡自定义方式 代码方式：配置灵活，但修改时需要重新打包发布 配置方式：直观，方便，无需重新打包发布，但是无法做全局配置 3. 饥饿加载 开启饥饿加载 指定饥饿加载的微服务名称 spring: cloud: nacos: server-addr: localhost:8848 # nacos 服务地址 discovery: cluster-name: SH # 集群名称 Nacos服务分级模型1. Nacos服务分级存储模型 一级是服务，例如userservice 二级是集群，例如杭州或上海 三级是实例，例如杭州机房的某台部署了userservice的服务器 2. 如何设置实例的集群属性修改application.yml文件，添加spring.cloud.nacos.discovery.cluster-name属性即可 Nacos负载均衡策略1. NacosRule负载均衡策略 优先选择同集群服务实例列表 本地集群找不到提供者，才去找其他集群寻找，并且会报警告 确定了可用实例列表后，再采用随机负载均衡挑选实例 Nacos注册中心 - 加权负载均衡1. 实例的权重控制 Nacos控制台可以设置势实例的权重值，0~1 同集群内的多个实例，权重越高被访问的频率越高 权重设置为0则完全不会被访问","categories":[{"name":"教程","slug":"教程","permalink":"https://aqu.iyunmc.cn/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"https://aqu.iyunmc.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"RabbitMq从入门到精通","slug":"blog/RabbitMq从入门到精通","date":"2023-03-07T11:50:00.000Z","updated":"2023-06-04T12:22:00.190Z","comments":true,"path":"blog/RabbitMq从入门到精通/","link":"","permalink":"https://aqu.iyunmc.cn/blog/RabbitMq%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/","excerpt":"什么是消息中间件？ 消息中间件基于队列模型实现异步&#x2F;同步传输数据 作用：可以实现支撑高并发、异步解耦、流量削峰、降低耦合度。 传统的http请求存在那些缺点","text":"什么是消息中间件？ 消息中间件基于队列模型实现异步&#x2F;同步传输数据 作用：可以实现支撑高并发、异步解耦、流量削峰、降低耦合度。 传统的http请求存在那些缺点 Http请求基于请求与响应的模型，在高并发的情况下，客户端发送大量的请求达到服务器端有可能会导致我们服务器端处理请求堆积。 Tomcat服务器处理每个请求都有自己独立的线程，如果超过最大线程数会将该请求缓存到队列中，如果请求堆积过多的情况下，有可能会导致tomcat服务器崩溃的问题。 所以一般都会在nginx入口实现限流，整合服务保护框架。 http请求处理业务逻辑如果比较耗时的情况下，容易造成客户端一直等待，阻塞等待过程中会导致客户端超时发生重试策略，有可能会引发幂等性问题。 注意事项：接口是为http协议的情况下，最好不要处理比较耗时的业务逻辑，耗时的业务逻辑应该单独交给多线程或者是mq处理。 Mq应用场景有哪些？ 异步发送短信 异步发送新人优惠券 处理一些比较耗时的操作 为什么需要使用mq可以实现支撑高并发、异步解耦、流量削峰、降低耦合度。 Mq与多线程之间区别 MQ可以实现异步&#x2F;解耦&#x2F;流量削峰问题； 多线程也可以实现异步，但是消耗到cpu资源，没有实现解耦。 Mq消息中间件名词 Producer 生产者：投递消息到MQ服务器端； Consumer 消费者：从MQ服务器端获取消息处理业务逻辑； Broker MQ服务器端 Topic 主题：分类业务逻辑发送短信主题、发送优惠券主题 Queue 存放消息模型 队列 先进先出 后进后出原则 数组&#x2F;链表 Message 生产者投递消息报文：json 主流mq区别对比 特性 ActiveMQ RabbitMQ RocketMQ Kafka 开发语言 java erlang java scala 单机吞吐量 万级 万级 10万级 10万级 时效性 ms级 us级 ms级 ms级以内 可用性 高(主从架构) 高(主从架构) 非常高(分布式架构) 非常高(分布式架构) 功能特性 成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好 基于erlang开发，所以并发能力很强，性能极其好，延时很低管理界面较丰富 MQ功能比较完备，扩展性佳 只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广 基于多线程队列简单实现mqimport com.alibaba.fastjson.JSONObject;import java.util.concurrent.LinkedBlockingDeque;public class STThreadMQ &#123; private static LinkedBlockingDeque&lt;JSONObject&gt; msgs = new LinkedBlockingDeque&lt;&gt;(); public static void main(String[] args) &#123; //生产线程 Thread producerThread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; while (true)&#123; Thread.sleep(1000); JSONObject data = new JSONObject(); data.put(&quot;userId&quot;,&quot;1234&quot;); //存入消息 msgs.offer(data); System.out.println(Thread.currentThread().getName()+ &quot;,&quot; +data); &#125; &#125;catch (Exception e)&#123; &#125; &#125; &#125;,&quot;生产者&quot;); producerThread.start(); //消费线程 Thread ConsumerThread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; while (true)&#123; JSONObject data = msgs.poll(); if (data != null)&#123; System.out.println(Thread.currentThread().getName()+ &quot;,&quot; +data); &#125; &#125; &#125;catch (Exception e)&#123; &#125; &#125; &#125;,&quot;消费者&quot;); ConsumerThread.start(); &#125;&#125; 生产者投递消息给MQ服务器端，MQ服务器端需要缓存该消息 如果mq服务器端宕机之后，消息如何保证不丢失 持久化机制 如果mq接收到生产者投递消息，如果消费者不在的情况下，该消息是否会丢失？ 不会丢失，消息确认机制 必须要消费者消费该消息成功之后，再通知给mq服务器端删除该消息。 Mq服务器端将该消息推送消费者： 消费者已经和mq服务器保持长连接。 消费者主动拉取消息： 消费者第一次刚启动的时候 Mq如何实现抗高并发思想 Mq消费者根据自身能力情况 ，拉取mq服务器端消息消费 默认的情况下是取出一条消息 缺点：存在延迟的问题 需要考虑mq消费者提高速率的问题 如何消费者提高速率：消费者实现集群、消费者批量获取消息即可 RabbitMQRabbitMQ基本介绍RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件），RabbitMQ服务器是用Erlang语言编写的。 RabitMQ官方网站: https://www.rabbitmq.com/ 1.点对点(简单)的队列 2.工作(公平性)队列模式 3.发布订阅模式 4.路由模式Routing 5.通配符模式Topics 6.RPC https://www.rabbitmq.com/getstarted.html RabbitMQ环境的基本安装 1.下载并安装erlang,下载地址：http://www.erlang.org/download 2.配置erlang环境变量信息 新增环境变量ERLANG_HOME&#x3D;erlang的安装地址 将%ERLANG_HOME%\\bin加入到path中 3.下载并安装RabbitMQ，下载地址：http://www.rabbitmq.com/download.html **注意: RabbitMQ 它依赖于Erlang,需要先安装Erlang。 https://www.rabbitmq.com/install-windows.html ** 启动Rabbitmq常见问题如果rabbitmq 启动成功无法访问 管理平台页面 进入到F:\\path\\rabbitmq\\rabbitmq\\rabbitmq_server-3.6.9\\sbin&gt; 执行 rabbitmq-plugins enable rabbitmq_management rabbitmqctl start_app Rabbitmq管理平台中心RabbitMQ 管理平台地址 http://127.0.0.1:15672 默认账号:guest&#x2F;guest 用户可以自己创建新的账号 Virtual Hosts: 像mysql有数据库的概念并且可以指定用户对库和表等操作的权限。那RabbitMQ呢？ RabbitMQ也有类似的权限管理。在RabbitMQ中可以虚拟消息服务器VirtualHost，每个VirtualHost相当月一个相对独立的RabbitMQ服务器，每个VirtualHost之间是相互隔离的。exchange、queue、message不能互通 默认的端口15672：rabbitmq管理平台端口号 默认的端口5672： rabbitmq消息中间内部通讯的端口 默认的端口号25672 rabbitmq集群的端口号 RabbitMQ常见名词&#x2F;Virtual Hosts---分类 &#x2F;队列 存放我们消息 Exchange 分派我们消息在那个队列存放起来 类似于nginx 15672---rabbitmq控制台管理平台 http协议 25672---rabbitmq 集群通信端口号 Amqp 5672---rabbitmq内部通信的一个端口号 快速入门RabbitMQ简单队列首先需要再RabbitMQ平台创建Virtual Hosts 和队列。 &#x2F;meiteVirtualHosts ----订单队列 ----支付队列 在RabbitMQ平台创建一个队列： 在编写生产者代码 import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Producer &#123; private static final String QUEUE_NAME = &quot;mayikt--queue&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.创建连接 Connection connection = RabbitMQConnection.getConnection(); //2.创建通道 Channel channel = connection.createChannel(); String msg = &quot;每特教育666&quot;; channel.basicPublish(null,QUEUE_NAME,null,msg.getBytes()); //关闭通道和连接 channel.close(); connection.close(); &#125;&#125; 在编写消费者代码 import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Consumer &#123; private static final String QUEUE_NAME = &quot;mayikt--queue&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; //1.创建连接 Connection connection = RabbitMQConnection.getConnection(); //2.设置通道 Channel channel = connection.createChannel(); DefaultConsumer defaultConsumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,byte[] body)throws IOException&#123; String msg = new String(body,&quot;UTF-8&quot;); System.out.println(&quot;消费者获取消息:&quot; + msg); &#125; &#125;; //3.监听队列 //autoAck true:自动签收 //autoAck false: channel.basicConsume(QUEUE_NAME,true,defaultConsumer); &#125;&#125; 连接代码 import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;public class RabbitMQConnection &#123; //获取连接 public static Connection getConnection() throws IOException, TimeoutException &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); //1.设置连接VirtualHost connectionFactory.setVirtualHost(&quot;/meiteVirtualHosts&quot;); //2.设置账号和密码 connectionFactory.setUsername(&quot;guest&quot;); connectionFactory.setPassword(&quot;guest&quot;); //3.mq连接信息地址 connectionFactory.setHost(&quot;127.0.0.1&quot;); connectionFactory.setPort(5672); return connectionFactory.newConnection(); &#125;&#125; RabbitMQ如何保证消息不丢失Mq如何保证消息不丢失： 生产者角色 确保生产者投递消息到MQ服务器端成功。 Ack 消息确认机制 同步或者异步的形式 方式1：Confirms 方式2：事务消息 消费者模式 在rabbitmq情况下： 必须要将消息消费成功之后，才会将该消息从mq服务器端中移除。 在kafka中的情况下： 不管是消费成功还是消费失败，该消息都不会立即从mq服务器端移除。 RabitMQ工作队列默认的传统队列是为均摊消费，存在不公平性；如果每个消费者速度不一样的情况下，均摊消费是不公平的，应该是能者多劳。 在通道中只需要设置basicQos为1即可，表示MQ服务器每次只会给消费者推送1条消息必须手动ack确认之后才会继续发送。channel.basicQos(1); import com.rabbitmq.client.*;import com.st.mq.RabbitMQConnection;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Consumer02 &#123; private static final String QUEUE_NAME = &quot;mayikt-queue&quot;; public static void main(String[] args) throws IOException, TimeoutException, IOException, TimeoutException &#123; // 1.创建连接 Connection connection = RabbitMQConnection.getConnection(); // 2.设置通道 Channel channel = connection.createChannel(); //指定我们消费者每次批量获取消息 channel.basicQos(1); DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; try &#123; Thread.sleep(100); &#125;catch (Exception e)&#123; &#125; String msg = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;消费者获取消息:&quot; + msg); //消费者完成，删除消息 channel.basicAck(envelope.getDeliveryTag(),false); &#125; &#125;; // 3.监听队列 channel.basicConsume(QUEUE_NAME, false, defaultConsumer); &#125;&#125; import com.rabbitmq.client.*;import com.st.mq.RabbitMQConnection;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Consumer01 &#123; private static final String QUEUE_NAME = &quot;mayikt-queue&quot;; public static void main(String[] args) throws IOException, TimeoutException, IOException, TimeoutException &#123; // 1.创建连接 Connection connection = RabbitMQConnection.getConnection(); // 2.设置通道 Channel channel = connection.createChannel(); //指定我们消费者每次批量获取消息 channel.basicQos(2); DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String msg = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;消费者获取消息:&quot; + msg); //消费者完成 删除消息 channel.basicAck(envelope.getDeliveryTag(),false); &#125; &#125;; // 3.监听队列 channel.basicConsume(QUEUE_NAME, false, defaultConsumer); &#125;&#125; RabbitMQ交换机类型Direct exchange（直连交换机） Fanout exchange（扇型交换机） Topic exchange（主题交换机） Headers exchange（头交换机） &#x2F;Virtual Hosts---区分不同的团队 ----队列 存放消息 ----交换机 路由消息存放在那个队列中 类似于nginx ---路由key 分发规则 RabbitMQ Fanout 发布订阅生产者发送一条消息，经过交换机转发到多个不同的队列，多个不同的队列就多个不同的消费者。 原理： 需要创建两个队列 ，每个队列对应一个消费者； 队列需要绑定我们交换机 生产者投递消息到交换机中，交换机在将消息分配给两个队列中都存放起来； 消费者从队列中获取这个消息。 生产者代码import com.mayikt.rabbitmq.RabbitMQConnection;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import java.io.IOException;import java.util.concurrent.TimeoutException;public class ProducerFanout &#123; /** * 定义交换机的名称 */ private static final String EXCHANGE_NAME = &quot;fanout_exchange&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; // 创建Connection Connection connection = RabbitMQConnection.getConnection(); // 创建Channel Channel channel = connection.createChannel(); // 通道关联交换机 channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;, true); String msg = &quot;每特教育6666&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, msg.getBytes()); channel.close(); connection.close(); &#125;&#125; 消费者代码邮件消费者import com.mayikt.rabbitmq.RabbitMQConnection;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class MailConsumer &#123; /** * 定义邮件队列 */ private static final String QUEUE_NAME = &quot;fanout_email_queue&quot;; /** * 定义交换机的名称 */ private static final String EXCHANGE_NAME = &quot;fanout_exchange&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; System.out.println(&quot;邮件消费者...&quot;); // 创建我们的连接 Connection connection = RabbitMQConnection.getConnection(); // 创建我们通道 final Channel channel = connection.createChannel(); // 关联队列消费者关联队列 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String msg = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;邮件消费者获取消息:&quot; + msg); &#125; &#125;; // 开始监听消息 自动签收 channel.basicConsume(QUEUE_NAME, true, defaultConsumer); &#125;&#125; 短信消费者public class SmsConsumer &#123; /** * 定义短信队列 */ private static final String QUEUE_NAME = &quot;fanout_email_sms&quot;; /** * 定义交换机的名称 */ private static final String EXCHANGE_NAME = &quot;fanout_exchange&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; System.out.println(&quot;短信消费者...&quot;); // 创建我们的连接 Connection connection = RabbitMQConnection.getConnection(); // 创建我们通道 final Channel channel = connection.createChannel(); // 关联队列消费者关联队列 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String msg = new String(body, &quot;UTF-8&quot;); System.out.println(&quot;短信消费者获取消息:&quot; + msg); &#125; &#125;; // 开始监听消息 自动签收 channel.basicConsume(QUEUE_NAME, true, defaultConsumer); &#125;&#125; Direct路由模式当交换机类型为direct类型时，根据队列绑定的路由建转发到具体的队列中存放消息 Topic主题模式当交换机类型为topic类型时，根据队列绑定的路由建模糊转发到具体的队列中存放。 #号表示支持匹配多个词； *号表示只能匹配一个词 SpringBoot整合RabbitMQMaven依赖&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!-- springboot-web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加springboot对amqp的支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.49&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置类：import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.FanoutExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Component;/** * @ClassName RabbitMQConfig * @Author song * @Version V1.0 **/@Componentpublic class RabbitMQConfig &#123; /** * 定义交换机 */ private String EXCHANGE_SPRINGBOOT_NAME = &quot;/mayikt_ex&quot;; /** * 短信队列 */ private String FANOUT_SMS_QUEUE = &quot;fanout_sms_queue&quot;; /** * 邮件队列 */ private String FANOUT_EMAIL_QUEUE = &quot;fanout_email_queue&quot;; /** * 配置smsQueue * * @return */ @Bean public Queue smsQueue() &#123; return new Queue(FANOUT_SMS_QUEUE); &#125; /** * 配置emailQueue * * @return */ @Bean public Queue emailQueue() &#123; return new Queue(FANOUT_EMAIL_QUEUE); &#125; /** * 配置fanoutExchange * * @return */ @Bean public FanoutExchange fanoutExchange() &#123; return new FanoutExchange(EXCHANGE_SPRINGBOOT_NAME); &#125; // 绑定交换机 sms @Bean public Binding bindingSmsFanoutExchange(Queue smsQueue, FanoutExchange fanoutExchange) &#123; return BindingBuilder.bind(smsQueue).to(fanoutExchange); &#125; // 绑定交换机 email @Bean public Binding bindingEmailFanoutExchange(Queue emailQueue, FanoutExchange fanoutExchange) &#123; return BindingBuilder.bind(emailQueue).to(fanoutExchange); &#125;&#125; 配置文件application.ymlspring: rabbitmq: ####连接地址 host: 127.0.0.1 ####端口号 port: 5672 ####账号 username: guest ####密码 password: guest ### 地址 virtual-host: /meiteVirtualHosts 生产者import org.springframework.amqp.core.AmqpTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @ClassName FanoutProducer * @Author song * @Version V1.0 **/@RestControllerpublic class FanoutProducer &#123; @Autowired private AmqpTemplate amqpTemplate; /** * 发送消息 * * @return */ @RequestMapping(&quot;/sendMsg&quot;) public String sendMsg(String msg) &#123; /** * 1.交换机名称 * 2.路由key名称 * 3.发送内容 */ amqpTemplate.convertAndSend(&quot;/mayikt_ex&quot;, &quot;&quot;, msg); return &quot;success&quot;; &#125;&#125; 消费者import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;/** * @ClassName FanoutEmailConsumer * @Author 蚂蚁课堂余胜军 QQ644064779 www.mayikt.com * @Version V1.0 **/@Slf4j@Component@RabbitListener(queues = &quot;fanout_email_queue&quot;)public class FanoutEmailConsumer &#123; @RabbitHandler public void process(String msg) &#123; log.info(&quot;&gt;&gt;邮件消费者消息msg:&#123;&#125;&lt;&lt;&quot;, msg); &#125;&#125; import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;/** * @ClassName fanout_sms_queue * @Author 蚂蚁课堂余胜军 QQ644064779 www.mayikt.com * @Version V1.0 **/@Slf4j@Component@RabbitListener(queues = &quot;fanout_sms_queue&quot;)public class FanoutSmsConsumer &#123; @RabbitHandler public void process(String msg) &#123; log.info(&quot;&gt;&gt;短信消费者消息msg:&#123;&#125;&lt;&lt;&quot;, msg); &#125;&#125; 生产者如何获取消费结果1. 根据业务来定 消费者消费成功结果： 1.能够在数据库中插入一条数据 2.Rocketmq 自带全局消息id，能够根据该全局消息获取消费结果 原理： 生产者投递消息到mq服务器，mq服务器端在这时候返回一个全局的消息id， 当我们消费者消费该消息成功之后，消费者会给我们mq服务器端发送通知标记该消息消费成功。 生产者获取到该消息全局id，每隔2s时间调用mq服务器端接口查询该消息是否有被消费成功。 异步返回一个全局id，前端使用ajax定时主动查询； 在rocketmq中，自带根据消息id查询是否消费成功 RabbitMQ死信队列死信队列产生的背景RabbitMQ死信队列俗称，备胎队列；消息中间件因为某种原因拒收该消息后，可以转移到死信队列中存放，死信队列也可以有交换机和路由key等。 产生死信队列的原因 消息投递到MQ中存放 消息已经过期 消费者没有及时的获取到我们消息，消息如果存放到mq服务器中过期之后，会转移到备胎死信队列存放。 队列达到最大的长度 （队列容器已经满了） 消费者消费多次消息失败，就会转移存放到死信队列中 死信队列的架构原理死信队列和普通队列区别不是很大 普通与死信队列都有自己独立的交换机和路由key、队列和消费者。 区别： 生产者投递消息先投递到我们普通交换机中，普通交换机在将该消息投到普通队列中缓存起来，普通队列对应有自己独立普通消费者。 如果生产者投递消息到普通队列中，普通队列发现该消息一直没有被消费者消费的情况下，在这时候会将该消息转移到死信（备胎）交换机中，死信（备胎）交换机对应有自己独立的 死信（备胎）队列 对应独立死信（备胎）消费者。 死信队列应用场景 30分钟订单超时设计 A. Redis过期key B. 死信延迟队列实现： 采用死信队列，创建一个普通队列没有对应的消费者消费消息，在30分钟过后就会将该消息转移到死信备胎消费者实现消费。 备胎死信消费者会根据该订单号码查询是否已经支付过，如果没有支付的情况下则会开始回滚库存操作。 RabbitMQ消息幂等问题RabbitMQ消息自动重试机制 当我们消费者处理执行我们业务代码的时候，如果抛出异常的情况下 在这时候mq会自动触发重试机制，默认的情况下rabbitmq是无限次数的重试。需要人为指定重试次数限制问题 在什么情况下消费者需要实现重试策略？ A. 消费者获取消息后，调用第三方接口，但是调用第三方接口失败呢？是否需要重试？ 该情况下需要实现重试策略，网络延迟只是暂时调用不通，重试多次有可能会调用通。 B. 消费者获取消息后，因为代码问题抛出数据异常，是否需要重试？ 该情况下是不需要实现重试策略，就算重试多次，最终还是失败的。 可以将日志存放起来，后期通过定时任务或者人工补偿形式。 如果是重试多次还是失败消息，需要重新发布消费者版本实现消费 可以使用死信队列 Mq在重试的过程中，有可能会引发消费者重复消费的问题。 Mq消费者需要解决 幂等性问题 幂等性 保证数据唯一 方式1： 生产者在投递消息的时候，生成一个全局唯一id，放在我们消息中。 Msg id&#x3D;123456 Msg id&#x3D;123456 Msg id&#x3D;123456 消费者获取到我们该消息，可以根据该全局唯一id实现去重复。 全局唯一id 根据业务来定的 订单号码作为全局的id 实际上还是需要再db层面解决数据防重复。 业务逻辑是在做insert操作 使用唯一主键约束 业务逻辑是在做update操作 使用乐观锁 当消费者业务逻辑代码中，抛出异常自动实现重试 （默认是无数次重试） 应该对RabbitMQ重试次数实现限制，比如最多重试5次，每次间隔3s；重试多次还是失败的情况下，存放到死信队列或者存放到数据库表中记录后期人工补偿 如何合理选择消息重试总结：如果消费者处理消息时，因为代码原因抛出异常是需要从新发布版本才能解决的，那么就不需要重试，重试也解决不了该问题的。存放到死信队列或者是数据库表记录、后期人工实现补偿。 Rabbitmq如何开启重试策略spring: rabbitmq: ####连接地址 host: 127.0.0.1 ####端口号 port: 5672 ####账号 username: guest ####密码 password: guest ### 地址 virtual-host: /meite_rabbitmq listener: simple: retry: ####开启消费者（程序出现异常的情况下会）进行重试 enabled: true ####最大重试次数 max-attempts: 5 ####重试间隔次数 initial-interval: 3000 消费者重试过程中，如何避免幂等性问题重试的过程中，为了避免业务逻辑重复执行，建议提前全局id提前查询，如果存在 的情况下，就无需再继续做该流程。 重试的次数最好有一定间隔次数，在数据库底层层面保证数据唯一性，比如加上唯一id。 SpringBoot开启消息确认机制配置文件新增 spring: rabbitmq: ####连接地址 host: 127.0.0.1 ####端口号 port: 5672 ####账号 username: guest ####密码 password: guest ### 地址 virtual-host: /meiteVirtualHosts listener: simple: retry: ####开启消费者（程序出现异常的情况下会）进行重试 enabled: true ####最大重试次数 max-attempts: 5 ####重试间隔次数 initial-interval: 3000 acknowledge-mode: manual datasource: url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: root driver-class-name: com.mysql.jdbc.Driver 消费者ack代码 @Slf4j@Component@RabbitListener(queues = &quot;fanout_order_queue&quot;)public class FanoutOrderConsumer &#123; @Autowired private OrderManager orderManager; @Autowired private OrderMapper orderMapper; @RabbitHandler public void process(OrderEntity orderEntity, Message message, Channel channel) throws IOException &#123;// try &#123; log.info(&quot;&gt;&gt;orderEntity:&#123;&#125;&lt;&lt;&quot;, orderEntity.toString()); String orderId = orderEntity.getOrderId(); if (StringUtils.isEmpty(orderId)) &#123; log.error(&quot;&gt;&gt;orderId is null&lt;&lt;&quot;); return; &#125; OrderEntity dbOrderEntity = orderMapper.getOrder(orderId); if (dbOrderEntity != null) &#123; log.info(&quot;&gt;&gt;该订单已经被消费过，无需重复消费!&lt;&lt;&quot;); // 无需继续重试 channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); return; &#125; int result = orderManager.addOrder(orderEntity); log.info(&quot;&gt;&gt;插入数据库中数据成功&lt;&lt;&quot;); if (result &gt;= 0) &#123; // 开启消息确认机制 channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); &#125;// int i = 1 / 0;// &#125; catch (Exception e) &#123;// // 将失败的消息记录下来，后期采用人工补偿的形式// &#125; &#125;&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://aqu.iyunmc.cn/categories/java/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://aqu.iyunmc.cn/tags/java/"}]},{"title":"SpringAMQP","slug":"blog/SpringAMQP","date":"2023-03-05T16:00:00.000Z","updated":"2023-06-05T07:36:14.941Z","comments":true,"path":"blog/SpringAMQP/","link":"","permalink":"https://aqu.iyunmc.cn/blog/SpringAMQP/","excerpt":"1.同步调用的优点 时效性较强，可以立即得到结果 2.同步调用的问题","text":"1.同步调用的优点 时效性较强，可以立即得到结果 2.同步调用的问题 耦合度高 性能和吞吐能力下降 有额外的资源消耗 有级联失败问题 3.异步通信的优点 耦合度低 吞吐量提升 故障隔离 流量削峰 4.异步通信的缺点 依赖于Broker的可靠性、安全性、吞吐能力 架构复杂了，业务没有明显的流程线，不好追踪管理 什么是MQMQ（MessageQueue），中文是消息队列，字面来看就是存放消息的队列，也就是事件驱动架构中的Broker RabbitMQ入门RabbitMQ中的几个概念 channel：操作MQ的工具 exchange：路由消息到队列中 queue：缓存消息 virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组 HelloWorld案例官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色： publisher：消息发布这，将消息发送到队列queue queue：消息队列，负责接收并缓存消息 consumer：订阅队列，处理队列中的消息 基本消息队列的消息发送流程 建立connection 创建channel 利用channel声明队列 利用channel向队列发送消息 基本消息队列的消息接收流程 建立connection 创建channel 利用channel声明队列 定义consumer的消费行为handleDelivery() 利用channel将消费者与队列绑定 SpringAMQP什么是SpringAMQPAMQP（Advanced Message Queuing Protocol） 是用于在应用程序或之间传递业务消息的开放标准 该协议与语言和平台无关，更符合微服务中独立性的要求。 SpringAMQP是基于AMQP协议定义的一套API规范，提供了模板来发送和接受消息。包含两部分，其中spring-amqp是基础抽象，spring-rabbit是底层的默认实现。 SpringAMQP如何接收消息？ 引入amqp的starter依赖 配置RabbitMQ地址 定义类，添加@Component注解 类中声明方法，添加@RabbitListener注解，方法参数就是消息 注意：消息一旦消费就会从队列中删除，RabbitMQ没有消息回溯功能 发布（Publish）、订阅（Subscribe）发布订阅模式与之前案例的区别就是允许将同意消息发送给多个消费者。实现方式是加入了exchange（交换机） 常见的exchange类型包括： Fanout：广播 Direct：路由 Topic：话题 注意：exchange负责消息路由，而不是存储，路由失败则消息丢失 SpringAMQP - FanoutExchangeFanoutExchange交换机的作用 接受publisher发送的消息 将消息按照规则路由到绑定的队列 不能缓存消息，路由失败，消息会丢失 FanoutExchange的会将消息路由到每个绑定的队列 DirectExchangeDirect交换机与Fanout交换机的差异 Fanout交换机将消息路由给每一个与之绑定的队列 Direct交换机根据RoutingKey判断路由给哪个队列 如果多个队列具有相同的RoutingKey，则与Fanout功能类似 基于@RabbitListener注解声明队列和交换机有哪些常见注解 @Queue @Exchange SpringAMQP - 消息转换器Spring的对消息对象的处理时由org.springframework.amqp.support.converter.MessageConverter来处理的。而默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化。 如果要修改只需要定义一个MessageConverter类型的Bean即可。推荐用JSON方式序列化，步骤如下： 在publisher服务引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.9.10&gt; &lt;/dependency&gt; - 在publisher服务声明MessageConverter：- ``` @Bean public MessageConverter jsonMessageConverter()&#123; return new Jackson2JsonMessageConverter(); &#125; SpringAMQP中消息的序列化和反序列化如何实现 利用MessageConverter实现的，默认是JDK的序列化 注意发送方和接收方必须使用相同的MessageConverter","categories":[{"name":"教程","slug":"教程","permalink":"https://aqu.iyunmc.cn/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"https://aqu.iyunmc.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"Redis","slug":"blog/Redis","date":"2022-10-10T16:00:00.000Z","updated":"2023-06-05T07:35:59.442Z","comments":true,"path":"blog/Redis/","link":"","permalink":"https://aqu.iyunmc.cn/blog/Redis/","excerpt":"认识NoSQL","text":"认识NoSQL SQL： 结构化（Structured） 关联的（Relational） SQL查询 ACID A（Atomicity）：原子性 C（Consistency）：一致性 I（Isolation）：隔离性 D（Durability）：持久性 Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 [1] NoSQL： 非结构化 无关联的 非SQL BASE 缓存穿透：缓存穿透是指查询一条数据库和缓存都没有的一条数据，就会 一直查询数据库，对数据库的访问压力就会增大。 常见的2种解决方案： 缓存空对象 优点：简单实现，维护方便 缺点： 额外的内存消耗 可能造成短期的不一致 布隆过滤 优点：内存占用较少，没有多余的key 缺点： 实现复杂 存在误判可能 增强id的复杂度，避免被猜测id规律 做好数据的基础格式校验 加强用户权限校验 做好热点参数的限流 缓存穿透：缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力 解决方案： 给不同的Key的TTL添加随机值 利用Redis集群提高服务的可用性 给缓存业务添加降级限流策略 给业务添加多级缓存 缓存击穿：缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击 解决方案： 互斥锁 逻辑过期 解决方案 优点 缺点 互斥锁 没有额外的内存消耗保证一致性实现简单 县城需要等待，性能受影响可能有死锁风险 逻辑过期 线程无需等待，性能较好 不保证一致性有额外内存消耗实现复杂 全局唯一ID生成策略： UUIDUUID是指在一台机器在同一时间中生成的数字在所有机器中都是唯一的。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12) 优点： 简单，代码方便 生成ID性能非常好，基本不会有性能问题，本地生成，没有网络消耗 全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对 缺点： 没有排序，无法保证趋势递增 UUID往往是使用字符串存储，查询的效率比较低 存储空间比较大，UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用，如果是海量数据库，就需要考虑存储量的问题 信息不安全，基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置 传输数据量大，并且不可读 Redis自增 优点： 不依赖于数据库，灵活方便，且性能优于数据库 数字ID天然排序，对分页或者需要排序的结果很有帮助 缺点： 如果系统中没有Redis，还需要引入新的组件，增加系统复杂度 需要编码和配置的工作量比较大 Redis是单线程的，若造成阻塞，则会引发高并发问题，需要处理好集群与主从关系 snowflake算法snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。生成的是一个64位的二进制正整数，然后转换成10进制的数。64位二进制数由如下部分组成： * SnowFlake的结构如下(每部分用-分开):* 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000* (1-10-10-10-10-10-1-5-5-12) (1-41-10-12) 优点 简单高效，生成速度快 时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增 灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求 缺点 依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成 在分布式环境上，每个服务器的时钟不可能完全同步，有时会出现不是全局递增的情况 数据库自增 优点： 简单，代码方便，性能可以接受 数字ID天然排序，对分页或者需要排序的结果很有帮助 缺点： 不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理 在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险 在性能达不到要求的情况下，比较难于扩展 如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦 分表分库的时候会有麻烦","categories":[{"name":"教程","slug":"教程","permalink":"https://aqu.iyunmc.cn/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Redis","slug":"redis","permalink":"https://aqu.iyunmc.cn/tags/redis/"}]},{"title":"SpringSecurity从入门到精通","slug":"blog/SpringSecurity从入门到精通","date":"2022-06-08T16:00:00.000Z","updated":"2023-06-05T07:34:31.395Z","comments":true,"path":"blog/SpringSecurity从入门到精通/","link":"","permalink":"https://aqu.iyunmc.cn/blog/SpringSecurity%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/","excerpt":"","text":"课程介绍 0. 简介​ Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。 ​ 一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。 ​ 一般Web应用的需要进行认证和授权。 ​ 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户 ​ 授权：经过认证后判断当前用户是否有权限进行某个操作 ​ 而认证和授权也是SpringSecurity作为安全框架的核心功能。 1. 快速入门1.1 准备工作​ 我们先要搭建一个简单的SpringBoot工程 ① 设置父工程 添加依赖 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ② 创建启动类 @SpringBootApplicationpublic class SecurityApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SecurityApplication.class,args); &#125;&#125; ③ 创建Controller import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 1.2 引入SpringSecurity​ 在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; ​ 引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。 ​ 必须登陆之后才能对接口进行访问。 2. 认证2.1 登陆校验流程 2.2 原理初探​ 想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。 2.2.1 SpringSecurity完整流程​ SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。 ​ 图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。 UsernamePasswordAuthenticationFilter:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。 ExceptionTranslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。 FilterSecurityInterceptor：负责权限校验的过滤器。 ​ ​ 我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。 2.2.2 认证流程详解 概念速查: Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。 AuthenticationManager接口：定义了认证Authentication的方法 UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。 UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。 2.3 解决问题2.3.1 思路分析登录 ​ ①自定义登录接口 ​ 调用ProviderManager的方法进行认证 如果认证通过生成jwt ​ 把用户信息存入redis中 ​ ②自定义UserDetailsService ​ 在这个实现类中去查询数据库 校验： ​ ①定义Jwt认证过滤器 ​ 获取token ​ 解析token获取其中的userid ​ 从redis中获取用户信息 ​ 存入SecurityContextHolder 2.3.2 准备工作①添加依赖 &lt;!--redis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--fastjson依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.33&lt;/version&gt;&lt;/dependency&gt;&lt;!--jwt依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; ② 添加Redis相关配置 import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.type.TypeFactory;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;import com.alibaba.fastjson.parser.ParserConfig;import org.springframework.util.Assert;import java.nio.charset.Charset;/** * Redis使用FastJson序列化 * * @author sg */public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt;&#123; public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); private Class&lt;T&gt; clazz; static &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); &#125; public FastJsonRedisSerializer(Class&lt;T&gt; clazz) &#123; super(); this.clazz = clazz; &#125; @Override public byte[] serialize(T t) throws SerializationException &#123; if (t == null) &#123; return new byte[0]; &#125; return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET); &#125; @Override public T deserialize(byte[] bytes) throws SerializationException &#123; if (bytes == null || bytes.length &lt;= 0) &#123; return null; &#125; String str = new String(bytes, DEFAULT_CHARSET); return JSON.parseObject(str, clazz); &#125; protected JavaType getJavaType(Class&lt;?&gt; clazz) &#123; return TypeFactory.defaultInstance().constructType(clazz); &#125;&#125; import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean @SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class); // 使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(serializer); // Hash的key也采用StringRedisSerializer的序列化方式 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(serializer); template.afterPropertiesSet(); return template; &#125;&#125; ③ 响应类 import com.fasterxml.jackson.annotation.JsonInclude;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@JsonInclude(JsonInclude.Include.NON_NULL)public class ResponseResult&lt;T&gt; &#123; /** * 状态码 */ private Integer code; /** * 提示信息，如果有错误时，前端可以获取该字段进行提示 */ private String msg; /** * 查询到的结果数据， */ private T data; public ResponseResult(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; public ResponseResult(Integer code, T data) &#123; this.code = code; this.data = data; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public ResponseResult(Integer code, String msg, T data) &#123; this.code = code; this.msg = msg; this.data = data; &#125;&#125; ④工具类 import io.jsonwebtoken.Claims;import io.jsonwebtoken.JwtBuilder;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;import java.util.Date;import java.util.UUID;/** * JWT工具类 */public class JwtUtil &#123; //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = &quot;sangeng&quot;; public static String getUUID()&#123; String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); return token; &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @return */ public static String createJWT(String subject) &#123; JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间 return builder.compact(); &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @param ttlMillis token超时时间 * @return */ public static String createJWT(String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间 return builder.compact(); &#125; private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123; SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; SecretKey secretKey = generalKey(); long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if(ttlMillis==null)&#123; ttlMillis=JwtUtil.JWT_TTL; &#125; long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); return Jwts.builder() .setId(uuid) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(&quot;sg&quot;) // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate); &#125; /** * 创建token * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间 return builder.compact(); &#125; public static void main(String[] args) throws Exception &#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;; Claims claims = parseJWT(token); System.out.println(claims); &#125; /** * 生成加密后的秘钥 secretKey * @return */ public static SecretKey generalKey() &#123; byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;); return key; &#125; /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception &#123; SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); &#125;&#125; import java.util.*;import java.util.concurrent.TimeUnit;@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)@Componentpublic class RedisCache&#123; @Autowired public RedisTemplate redisTemplate; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 */ public &lt;T&gt; void setCacheObject(final String key, final T value) &#123; redisTemplate.opsForValue().set(key, value); &#125; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 * @param timeout 时间 * @param timeUnit 时间颗粒度 */ public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit) &#123; redisTemplate.opsForValue().set(key, value, timeout, timeUnit); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout) &#123; return expire(key, timeout, TimeUnit.SECONDS); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @param unit 时间单位 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout, final TimeUnit unit) &#123; return redisTemplate.expire(key, timeout, unit); &#125; /** * 获得缓存的基本对象。 * * @param key 缓存键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; T getCacheObject(final String key) &#123; ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue(); return operation.get(key); &#125; /** * 删除单个对象 * * @param key */ public boolean deleteObject(final String key) &#123; return redisTemplate.delete(key); &#125; /** * 删除集合对象 * * @param collection 多个对象 * @return */ public long deleteObject(final Collection collection) &#123; return redisTemplate.delete(collection); &#125; /** * 缓存List数据 * * @param key 缓存的键值 * @param dataList 待缓存的List数据 * @return 缓存的对象 */ public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList) &#123; Long count = redisTemplate.opsForList().rightPushAll(key, dataList); return count == null ? 0 : count; &#125; /** * 获得缓存的list对象 * * @param key 缓存的键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; List&lt;T&gt; getCacheList(final String key) &#123; return redisTemplate.opsForList().range(key, 0, -1); &#125; /** * 缓存Set * * @param key 缓存键值 * @param dataSet 缓存的数据 * @return 缓存数据的对象 */ public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet) &#123; BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key); Iterator&lt;T&gt; it = dataSet.iterator(); while (it.hasNext()) &#123; setOperation.add(it.next()); &#125; return setOperation; &#125; /** * 获得缓存的set * * @param key * @return */ public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key) &#123; return redisTemplate.opsForSet().members(key); &#125; /** * 缓存Map * * @param key * @param dataMap */ public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap) &#123; if (dataMap != null) &#123; redisTemplate.opsForHash().putAll(key, dataMap); &#125; &#125; /** * 获得缓存的Map * * @param key * @return */ public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * 往Hash中存入数据 * * @param key Redis键 * @param hKey Hash键 * @param value 值 */ public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value) &#123; redisTemplate.opsForHash().put(key, hKey, value); &#125; /** * 获取Hash中的数据 * * @param key Redis键 * @param hKey Hash键 * @return Hash中的对象 */ public &lt;T&gt; T getCacheMapValue(final String key, final String hKey) &#123; HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash(); return opsForHash.get(key, hKey); &#125; /** * 删除Hash中的数据 * * @param key * @param hkey */ public void delCacheMapValue(final String key, final String hkey) &#123; HashOperations hashOperations = redisTemplate.opsForHash(); hashOperations.delete(key, hkey); &#125; /** * 获取多个Hash中的数据 * * @param key Redis键 * @param hKeys Hash键集合 * @return Hash对象集合 */ public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys) &#123; return redisTemplate.opsForHash().multiGet(key, hKeys); &#125; /** * 获得缓存的基本对象列表 * * @param pattern 字符串前缀 * @return 对象列表 */ public Collection&lt;String&gt; keys(final String pattern) &#123; return redisTemplate.keys(pattern); &#125;&#125; import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class WebUtils&#123; /** * 将字符串渲染到客户端 * * @param response 渲染对象 * @param string 待渲染的字符串 * @return null */ public static String renderString(HttpServletResponse response, String string) &#123; try &#123; response.setStatus(200); response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.getWriter().print(string); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; ⑤实体类 import java.io.Serializable;import java.util.Date;/** * 用户表(User)实体类 * * @author 三更 */@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Serializable &#123; private static final long serialVersionUID = -40356785423868312L; /** * 主键 */ private Long id; /** * 用户名 */ private String userName; /** * 昵称 */ private String nickName; /** * 密码 */ private String password; /** * 账号状态（0正常 1停用） */ private String status; /** * 邮箱 */ private String email; /** * 手机号 */ private String phonenumber; /** * 用户性别（0男，1女，2未知） */ private String sex; /** * 头像 */ private String avatar; /** * 用户类型（0管理员，1普通用户） */ private String userType; /** * 创建人的用户id */ private Long createBy; /** * 创建时间 */ private Date createTime; /** * 更新人 */ private Long updateBy; /** * 更新时间 */ private Date updateTime; /** * 删除标志（0代表未删除，1代表已删除） */ private Integer delFlag;&#125; 2.3.3 实现2.3.3.1 数据库校验用户​ 从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。 准备工作​ 我们先创建一个用户表， 建表语句如下： CREATE TABLE `sys_user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;, `nick_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;, `password` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;, `status` CHAR(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;, `email` VARCHAR(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `sex` CHAR(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;, `avatar` VARCHAR(128) DEFAULT NULL COMMENT &#x27;头像&#x27;, `user_type` CHAR(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;, `create_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;, `create_time` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `update_time` DATETIME DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` INT(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27; ​ 引入MybatisPuls和mysql驱动的依赖 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; ​ 配置数据库信息 spring: datasource: url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver ​ 定义Mapper接口 public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; ​ 修改User实体类 类名上加@TableName(value = &quot;sys_user&quot;) ,id字段上加 @TableId ​ 配置Mapper扫描 @SpringBootApplication@MapperScan(&quot;com.sangeng.mapper&quot;)public class SimpleSecurityApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class); System.out.println(run); &#125;&#125; ​ 添加junit依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; ​ 测试MP是否能正常使用 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@SpringBootTestpublic class MapperTest &#123; @Autowired private UserMapper userMapper; @Test public void testUserMapper()&#123; List&lt;User&gt; users = userMapper.selectList(null); System.out.println(users); &#125;&#125; 核心代码实现创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //根据用户名查询用户信息 LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); //如果查询不到数据就通过抛出异常来给出提示 if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //TODO 根据用户查询权限信息 添加到LoginUser中 //封装成UserDetails对象返回 return new LoginUser(user); &#125;&#125; 因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Data@NoArgsConstructor@AllArgsConstructorpublic class LoginUser implements UserDetails &#123; private User user; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return null; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; 注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如 这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。 2.3.3.2 密码加密存储​ 实际项目中我们不会把密码明文存储在数据库中。 ​ 默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。 ​ 我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。 ​ 我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。 ​ 我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 2.3.3.3 登陆接口​ 接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。 ​ 在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。 ​ 认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。 @RestControllerpublic class LoginController &#123; @Autowired private LoginServcie loginServcie; @PostMapping(&quot;/user/login&quot;) public ResponseResult login(@RequestBody User user)&#123; return loginServcie.login(user); &#125;&#125; /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; ​ @Servicepublic class LoginServiceImpl implements LoginServcie &#123; @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisCache redisCache; @Override public ResponseResult login(User user) &#123; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if(Objects.isNull(authenticate))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //使用userid生成token LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); //authenticate存入redis redisCache.setCacheObject(&quot;login:&quot;+userId,loginUser); //把token响应给前端 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;,jwt); return new ResponseResult(200,&quot;登陆成功&quot;,map); &#125;&#125; 2.3.3.4 认证过滤器​ 我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。 ​ 使用userid去redis中获取对应的LoginUser对象。 ​ 然后封装Authentication对象存入SecurityContextHolder @Componentpublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123; @Autowired private RedisCache redisCache; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; //获取token String token = request.getHeader(&quot;token&quot;); if (!StringUtils.hasText(token)) &#123; //放行 filterChain.doFilter(request, response); return; &#125; //解析token String userid; try &#123; Claims claims = JwtUtil.parseJWT(token); userid = claims.getSubject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;token非法&quot;); &#125; //从redis中获取用户信息 String redisKey = &quot;login:&quot; + userid; LoginUser loginUser = redisCache.getCacheObject(redisKey); if(Objects.isNull(loginUser))&#123; throw new RuntimeException(&quot;用户未登录&quot;); &#125; //存入SecurityContextHolder //TODO 获取权限信息封装到Authentication中 UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser,null,null); SecurityContextHolder.getContext().setAuthentication(authenticationToken); //放行 filterChain.doFilter(request, response); &#125;&#125; /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Autowired JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter; @Override protected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //把token校验过滤器添加到过滤器链中 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; 2.3.3.5 退出登陆​ 我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class LoginServiceImpl implements LoginServcie &#123; @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisCache redisCache; @Override public ResponseResult login(User user) &#123; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if(Objects.isNull(authenticate))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //使用userid生成token LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); //authenticate存入redis redisCache.setCacheObject(&quot;login:&quot;+userId,loginUser); //把token响应给前端 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;,jwt); return new ResponseResult(200,&quot;登陆成功&quot;,map); &#125; @Override public ResponseResult logout() &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Long userid = loginUser.getUser().getId(); redisCache.deleteObject(&quot;login:&quot;+userid); return new ResponseResult(200,&quot;退出成功&quot;); &#125;&#125; 3. 授权3.0 权限系统的作用​ 例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。 ​ 总结起来就是不同的用户可以使用不同的功能。这就是权限系统要去实现的效果。 ​ 我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。 ​ 所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。 ​ 3.1 授权基本流程​ 在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。 ​ 所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。 ​ 然后设置我们的资源所需要的权限即可。 3.2 授权实现3.2.1 限制访问资源所需权限​ SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。 ​ 但是要使用它我们需要先开启相关配置。 @EnableGlobalMethodSecurity(prePostEnabled = true) ​ 然后就可以使用对应的注解。@PreAuthorize @RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;test&#x27;)&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 3.2.2 封装权限信息​ 我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。 ​ 我们先直接把权限信息写死封装到UserDetails中进行测试。 ​ 我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。 package com.sangeng.domain;import com.alibaba.fastjson.annotation.JSONField;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.Collection;import java.util.List;import java.util.stream.Collectors;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Data@NoArgsConstructorpublic class LoginUser implements UserDetails &#123; private User user; //存储权限信息 private List&lt;String&gt; permissions; public LoginUser(User user,List&lt;String&gt; permissions) &#123; this.user = user; this.permissions = permissions; &#125; //存储SpringSecurity所需要的权限信息的集合 @JSONField(serialize = false) private List&lt;GrantedAuthority&gt; authorities; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; if(authorities!=null)&#123; return authorities; &#125; //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中 authorities = permissions.stream(). map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); return authorities; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; ​ LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。 package com.sangeng.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;import com.sangeng.domain.LoginUser;import com.sangeng.domain.User;import com.sangeng.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Objects;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //TODO 根据用户查询权限信息 添加到LoginUser中 List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;)); return new LoginUser(user,list); &#125;&#125; 3.2.3 从数据库查询权限信息3.2.3.1 RBAC权限模型​ RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。 ​ 3.2.3.2 准备工作CREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;USE `sg_security`;/*Table structure for table `sys_menu` */DROP TABLE IF EXISTS `sys_menu`;CREATE TABLE `sys_menu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `menu_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;菜单名&#x27;, `path` varchar(200) DEFAULT NULL COMMENT &#x27;路由地址&#x27;, `component` varchar(255) DEFAULT NULL COMMENT &#x27;组件路径&#x27;, `visible` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0显示 1隐藏）&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0正常 1停用）&#x27;, `perms` varchar(100) DEFAULT NULL COMMENT &#x27;权限标识&#x27;, `icon` varchar(100) DEFAULT &#x27;#&#x27; COMMENT &#x27;菜单图标&#x27;, `create_by` bigint(20) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(20) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `del_flag` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;是否删除（0未删除 1已删除）&#x27;, `remark` varchar(500) DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;菜单表&#x27;;/*Table structure for table `sys_role` */DROP TABLE IF EXISTS `sys_role`;CREATE TABLE `sys_role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(128) DEFAULT NULL, `role_key` varchar(100) DEFAULT NULL COMMENT &#x27;角色权限字符串&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;角色状态（0正常 1停用）&#x27;, `del_flag` int(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;del_flag&#x27;, `create_by` bigint(200) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(200) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `remark` varchar(500) DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;角色表&#x27;;/*Table structure for table `sys_role_menu` */DROP TABLE IF EXISTS `sys_role_menu`;CREATE TABLE `sys_role_menu` ( `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#x27;角色ID&#x27;, `menu_id` bigint(200) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单id&#x27;, PRIMARY KEY (`role_id`,`menu_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;/*Table structure for table `sys_user` */DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;, `nick_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;, `password` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;, `email` varchar(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `phonenumber` varchar(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `sex` char(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;, `avatar` varchar(128) DEFAULT NULL COMMENT &#x27;头像&#x27;, `user_type` char(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;, `create_by` bigint(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;, `create_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_by` bigint(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `update_time` datetime DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;;/*Table structure for table `sys_user_role` */DROP TABLE IF EXISTS `sys_user_role`;CREATE TABLE `sys_user_role` ( `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27;, `role_id` bigint(200) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;角色id&#x27;, PRIMARY KEY (`user_id`,`role_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; SELECT DISTINCT m.`perms`FROM sys_user_role ur LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id` LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id` LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`WHERE user_id = 2 AND r.`status` = 0 AND m.`status` = 0 package com.sangeng.domain;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import com.fasterxml.jackson.annotation.JsonInclude;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.Date;/** * 菜单表(Menu)实体类 * * @author makejava * @since 2021-11-24 15:30:08 */@TableName(value=&quot;sys_menu&quot;)@Data@AllArgsConstructor@NoArgsConstructor@JsonInclude(JsonInclude.Include.NON_NULL)public class Menu implements Serializable &#123; private static final long serialVersionUID = -54979041104113736L; @TableId private Long id; /** * 菜单名 */ private String menuName; /** * 路由地址 */ private String path; /** * 组件路径 */ private String component; /** * 菜单状态（0显示 1隐藏） */ private String visible; /** * 菜单状态（0正常 1停用） */ private String status; /** * 权限标识 */ private String perms; /** * 菜单图标 */ private String icon; private Long createBy; private Date createTime; private Long updateBy; private Date updateTime; /** * 是否删除（0未删除 1已删除） */ private Integer delFlag; /** * 备注 */ private String remark;&#125; 3.2.3.3 代码实现​ 我们只需要根据用户id去查询到其所对应的权限信息即可。 ​ 所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。 import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.sangeng.domain.Menu;import java.util.List;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */public interface MenuMapper extends BaseMapper&lt;Menu&gt; &#123; List&lt;String&gt; selectPermsByUserId(Long id);&#125; ​ 尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sangeng.mapper.MenuMapper&quot;&gt; &lt;select id=&quot;selectPermsByUserId&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT DISTINCT m.`perms` FROM sys_user_role ur LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id` LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id` LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id` WHERE user_id = #&#123;userid&#125; AND r.`status` = 0 AND m.`status` = 0 &lt;/select&gt;&lt;/mapper&gt; ​ 在application.yml中配置mapperXML文件的位置 spring: datasource: url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver redis: host: localhost port: 6379mybatis-plus: mapper-locations: classpath*:/mapper/**/*.xml ​ 然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Autowired private MenuMapper menuMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; List&lt;String&gt; permissionKeyList = menuMapper.selectPermsByUserId(user.getId());// //测试写法// List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;)); return new LoginUser(user,permissionKeyList); &#125;&#125; 4. 自定义失败处理​ 我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。 ​ 在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。 ​ 如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。 ​ 如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。 ​ 所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。 ①自定义实现类 @Componentpublic class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), &quot;权限不足&quot;); String json = JSON.toJSONString(result); WebUtils.renderString(response,json); &#125;&#125; /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Componentpublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), &quot;认证失败请重新登录&quot;); String json = JSON.toJSONString(result); WebUtils.renderString(response,json); &#125;&#125; ②配置给SpringSecurity ​ ​ 先注入对应的处理器 @Autowiredprivate AuthenticationEntryPoint authenticationEntryPoint;@Autowiredprivate AccessDeniedHandler accessDeniedHandler; ​ 然后我们可以使用HttpSecurity对象的方法去配置。 http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint). accessDeniedHandler(accessDeniedHandler); 5. 跨域​ 浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 ​ 前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。 ​ 所以我们就要处理一下，让前端能进行跨域请求。 ①先对SpringBoot配置，运行跨域请求 @Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; // 设置允许跨域的路径 registry.addMapping(&quot;/**&quot;) // 设置允许跨域请求的域名 .allowedOriginPatterns(&quot;*&quot;) // 是否允许cookie .allowCredentials(true) // 设置允许的请求方式 .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;) // 设置允许的header属性 .allowedHeaders(&quot;*&quot;) // 跨域允许时间 .maxAge(3600); &#125;&#125; ②开启SpringSecurity的跨域访问 由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。 @Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //添加过滤器 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); //配置异常处理器 http.exceptionHandling() //配置认证失败处理器 .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler); //允许跨域 http.cors();&#125; 6. 遗留小问题其它权限校验方法​ 我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。 ​ ​ 这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。 ​ hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。 ​ 它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。 ​ hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。 @PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;,&#x27;test&#x27;,&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; ​ hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 @PreAuthorize(&quot;hasRole(&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; ​ hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 @PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; 自定义权限校验方法​ 我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。 @Component(&quot;ex&quot;)public class SGExpressionRoot &#123; public boolean hasAuthority(String authority)&#123; //获取当前用户的权限 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); List&lt;String&gt; permissions = loginUser.getPermissions(); //判断用户权限集合中是否存在authority return permissions.contains(authority); &#125;&#125; ​ 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法 @RequestMapping(&quot;/hello&quot;)@PreAuthorize(&quot;@ex.hasAuthority(&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; 基于配置的权限控制​ 我们也可以在配置类中使用使用配置的方式对资源进行权限控制。 @Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() .antMatchers(&quot;/testCors&quot;).hasAuthority(&quot;system:dept:list222&quot;) // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //添加过滤器 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); //配置异常处理器 http.exceptionHandling() //配置认证失败处理器 .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler); //允许跨域 http.cors();&#125; CSRF​ CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。 ​ https://blog.csdn.net/freeking101/article/details/86537087 ​ SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。 ​ 我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。 认证成功处理器​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。 ​ 我们也可以自己去自定义成功处理器进行成功后的相应处理。 @Componentpublic class SGSuccessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println(&quot;认证成功了&quot;); &#125;&#125; @Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin().successHandler(successHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 认证失败处理器​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。 ​ 我们也可以自己去自定义失败处理器进行失败后的相应处理。 @Componentpublic class SGFailureHandler implements AuthenticationFailureHandler &#123; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; System.out.println(&quot;认证失败了&quot;); &#125;&#125; @Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// 配置认证成功处理器 .successHandler(successHandler)// 配置认证失败处理器 .failureHandler(failureHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 登出成功处理器@Componentpublic class SGLogoutSuccessHandler implements LogoutSuccessHandler &#123; @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println(&quot;注销成功&quot;); &#125;&#125; @Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Autowired private LogoutSuccessHandler logoutSuccessHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// 配置认证成功处理器 .successHandler(successHandler)// 配置认证失败处理器 .failureHandler(failureHandler); http.logout() //配置注销成功处理器 .logoutSuccessHandler(logoutSuccessHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 其他认证方案畅想7. 源码讲解​ 投票过50更新源码讲解","categories":[{"name":"教程","slug":"教程","permalink":"https://aqu.iyunmc.cn/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://aqu.iyunmc.cn/tags/java/"}]},{"title":"测试「文章内链接作文本的话无法生成静态文件」","slug":"blog/2020-03-06-test-url","date":"2020-03-05T16:00:00.000Z","updated":"2023-06-05T07:17:29.760Z","comments":true,"path":"blog/2020-03-06-test-url/","link":"","permalink":"https://aqu.iyunmc.cn/blog/2020-03-06-test-url/","excerpt":"","text":"https://volantis.js.org/v6/tag-plugins/#text5、测试Tomcat是否配置成功：打开浏览器，输入在地址栏中输入： http://localhost:8080 的运行结果如下图即为即为配置成功！（因为Tomcat已经在运行再次打开会报错） 相关 Issue： #164 结论：存在这篇文章的情况下能够成功 deploy ，说明这不是主题的 BUG。 markdwon 解析插件为 hexo-renderer-marked 时此插件默认会自动识别 URL ，且原文链接前后没有空格，所以链接前后增加一个空格或者在根目录配置文件中设置 autolink: false 都可以避免 deploy 报错。插件：hexo-renderer-marked https://cdn1.tianli0.top/gh/ino0613/Aquino@output/github-contribution-grid-snake.svg","categories":[{"name":"test","slug":"test","permalink":"https://aqu.iyunmc.cn/categories/test/"}],"tags":[]},{"title":"Code Highlight Style test","slug":"blog/code-highlight","date":"2019-07-25T08:43:00.000Z","updated":"2023-05-29T07:21:56.392Z","comments":true,"path":"blog/code-highlight/","link":"","permalink":"https://aqu.iyunmc.cn/blog/code-highlight/","excerpt":"Make sure all the code blocks highlighted correctly. All the code samples are come from the demo of https://highlightjs.org","text":"Make sure all the code blocks highlighted correctly. All the code samples are come from the demo of https://highlightjs.org Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry&#x27;s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. #[derive(Debug)]pub enum State &#123; Start, Transient, Closed,&#125;impl From&lt;&amp;&#x27;a str&gt; for State &#123; fn from(s: &amp;&#x27;a str) -&gt; Self &#123; match s &#123; &quot;start&quot; =&gt; State::Start, &quot;closed&quot; =&gt; State::Closed, _ =&gt; unreachable!(), &#125; &#125;&#125; [ &#123; &quot;title&quot;: &quot;apples&quot;, &quot;count&quot;: [12000, 20000], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;, &#123; &quot;title&quot;: &quot;oranges&quot;, &quot;count&quot;: [17500, null], &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125; &#125;] class MyClass &#123; public static myValue: string; constructor(init: string) &#123; this.myValue = init; &#125;&#125;import fs = require(&quot;fs&quot;);module MyModule &#123; export interface MyInterface extends Other &#123; myProperty: any; &#125;&#125;declare magicNumber number;myArray.forEach(() =&gt; &#123; &#125;); // fat arrow syntax @requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0): r&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27; if param1 &gt; param2: # interesting print &#x27;Gre\\&#x27;ater&#x27; return (param2 - param1 + 1 + 0b10l) or Noneclass SomeClass: pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27; &lt;!DOCTYPE html&gt;&lt;title&gt;Title&lt;/title&gt;&lt;style&gt;body &#123;width: 500px;&#125;&lt;/style&gt;&lt;script type=&quot;application/javascript&quot;&gt; function $init() &#123;return true;&#125;&lt;/script&gt;&lt;body&gt; &lt;p checked class=&quot;title&quot; id=&#x27;title&#x27;&gt;Title&lt;/p&gt; &lt;!-- here goes the rest of the page --&gt;&lt;/body&gt; function $initHighlight(block, cls) &#123; try &#123; if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) + ` class=&quot;$&#123;cls&#125;&quot;`; &#125; catch (e) &#123; /* handle exception */ &#125; for (var i = 0 / 2; i &lt; classes.length; i++) &#123; if (checkCondition(classes[i]) === undefined) console.log(&#x27;undefined&#x27;); &#125; return ( &lt;div&gt; &lt;web-component&gt;&#123;block&#125;&lt;/web-component&gt; &lt;/div&gt; )&#125;export $initHighlight; #include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125; CREATE TABLE &quot;topic&quot; ( &quot;id&quot; serial NOT NULL PRIMARY KEY, &quot;forum_id&quot; integer NOT NULL, &quot;subject&quot; varchar(255) NOT NULL);ALTER TABLE &quot;topic&quot;ADD CONSTRAINT forum_id FOREIGN KEY (&quot;forum_id&quot;)REFERENCES &quot;forum&quot; (&quot;id&quot;);-- Initialsinsert into &quot;topic&quot; (&quot;forum_id&quot;, &quot;subject&quot;)values (2, &#x27;D&#x27;&#x27;artagnian&#x27;); #import &lt;UIKit/UIKit.h&gt;#import &quot;Dependency.h&quot;@protocol WorldDataSource@optional- (NSString *)worldName;@required- (BOOL)allowsToLive;@end// comment@property (nonatomic, readonly) NSString *title;- (IBAction) show;@end /** * @author John Smith &lt;john.smith@example.com&gt;*/package l2f.gameserver.model;public abstract class L2Char extends L2Object &#123; public static final Short ERROR = 0x0001; public void moveTo(int x, int y, int z) &#123; _ai = null; log(&quot;Should not be called&quot;); if (1 &gt; 5) &#123; // wtf!? return; &#125; &#125;&#125; import Foundation@objc class Person: Entity &#123; var name: String! var age: Int! init(name: String, age: Int) &#123; /* /* ... */ */ &#125; // Return a descriptive string for this person func description(offset: Int = 0) -&gt; String &#123; return &quot;\\(name) is \\(age + offset) years old&quot; &#125;&#125; @font-face &#123; font-family: Chunkfive; src: url(&#x27;Chunkfive.otf&#x27;);&#125;body, .usertext &#123; color: #F0F0F0; background: #600; font-family: Chunkfive, sans;&#125;@import url(print.css);@media print &#123; a[href^=http]::after &#123; content: attr(href) &#125;&#125; # The Greeter classclass Greeter def initialize(name) @name = name.capitalize end def salute puts &quot;Hello #&#123;@name&#125;!&quot; endendg = Greeter.new(&quot;world&quot;)g.salute # MakefileBUILDDIR = _buildEXTRAS ?= $(BUILDDIR)/extras.PHONY: main cleanmain: @echo &quot;Building main facility...&quot; build_main $(BUILDDIR)clean: rm -rf $(BUILDDIR)/* package mainimport &quot;fmt&quot;func main() &#123; ch := make(chan float64) ch &lt;- 1.0e10 // magic number x, ok := &lt;- ch defer fmt.Println(`exitting now\\`) go println(len(&quot;hello world!&quot;)) return&#125; #!/bin/bash###### CONFIGACCEPTED_HOSTS=&quot;/root/.hag_accepted.conf&quot;BE_VERBOSE=falseif [ &quot;$UID&quot; -ne 0 ]then echo &quot;Superuser rights required&quot; exit 2figenApacheConf()&#123; echo -e &quot;# Host $&#123;HOME_DIR&#125;$1/$2 :&quot;&#125; ; boilerplate[package]name = &quot;some_name&quot;authors = [&quot;Author&quot;]description = &quot;This is \\a description&quot;[[lib]]name = $&#123;NAME&#125;default = Trueauto = nocounter = 1_000 长文本测试 #include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; /* An annoying &quot;Hello World&quot; example */ for (auto i = 0; i &lt; 0xFFFF; i++) cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; char c = &#x27;\\n&#x27;; unordered_map &lt;string, vector&lt;string&gt; &gt; m; m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error return -2e3 + 12l;&#125;","categories":[],"tags":[]}],"categories":[{"name":"面试","slug":"面试","permalink":"https://aqu.iyunmc.cn/categories/%E9%9D%A2%E8%AF%95/"},{"name":"教程","slug":"教程","permalink":"https://aqu.iyunmc.cn/categories/%E6%95%99%E7%A8%8B/"},{"name":"Java","slug":"java","permalink":"https://aqu.iyunmc.cn/categories/java/"},{"name":"test","slug":"test","permalink":"https://aqu.iyunmc.cn/categories/test/"}],"tags":[{"name":"Redis","slug":"redis","permalink":"https://aqu.iyunmc.cn/tags/redis/"},{"name":"Java","slug":"java","permalink":"https://aqu.iyunmc.cn/tags/java/"},{"name":"Linux","slug":"linux","permalink":"https://aqu.iyunmc.cn/tags/linux/"},{"name":"中间件","slug":"中间件","permalink":"https://aqu.iyunmc.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]}